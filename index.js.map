{"version":3,"names":[],"mappings":"","sources":["index.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enableBodyScroll = exports.clearAllBodyScrollLocks = exports.disableBodyScroll = void 0;\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\n// Older browsers don't support event options, feature detect it.\n// Adopted and modified solution from Bohdan Didukh (2017)\n// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi\nvar hasPassiveEvents = false;\n\nif (typeof window !== 'undefined') {\n  var passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true;\n      return undefined;\n    }\n\n  };\n  window.addEventListener('testPassive', null, passiveTestOptions);\n  window.removeEventListener('testPassive', null, passiveTestOptions);\n}\n\nvar isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && /iP(ad|hone|od)/.test(window.navigator.platform);\nvar locks = [];\nvar documentListenerAdded = false;\nvar initialClientY = -1;\nvar previousBodyOverflowSetting;\nvar previousBodyPaddingRight; // returns true if `el` should be allowed to receive touchmove events\n\nvar allowTouchMove = function allowTouchMove(el) {\n  return locks.some(function (lock) {\n    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {\n      return true;\n    }\n\n    return false;\n  });\n};\n\nvar preventDefault = function preventDefault(rawEvent) {\n  var e = rawEvent || window.event; // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n\n  if (allowTouchMove(e.target)) {\n    return true;\n  } // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom)\n\n\n  if (e.touches.length > 1) return true;\n  if (e.preventDefault) e.preventDefault();\n  return false;\n};\n\nvar setOverflowHidden = function setOverflowHidden(options) {\n  // Setting overflow on body/documentElement synchronously in Desktop Safari slows down\n  // the responsiveness for some reason. Setting within a setTimeout fixes this.\n  setTimeout(function () {\n    // If previousBodyPaddingRight is already set, don't set it again.\n    if (previousBodyPaddingRight === undefined) {\n      var reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;\n      var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;\n\n      if (reserveScrollBarGap && scrollBarGap > 0) {\n        previousBodyPaddingRight = document.body.style.paddingRight;\n        document.body.style.paddingRight = \"\".concat(scrollBarGap, \"px\");\n      }\n    } // If previousBodyOverflowSetting is already set, don't set it again.\n\n\n    if (previousBodyOverflowSetting === undefined) {\n      previousBodyOverflowSetting = document.body.style.overflow;\n      document.body.style.overflow = 'hidden';\n    }\n  });\n};\n\nvar restoreOverflowSetting = function restoreOverflowSetting() {\n  // Setting overflow on body/documentElement synchronously in Desktop Safari slows down\n  // the responsiveness for some reason. Setting within a setTimeout fixes this.\n  setTimeout(function () {\n    if (previousBodyPaddingRight !== undefined) {\n      document.body.style.paddingRight = previousBodyPaddingRight; // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n      // can be set again.\n\n      previousBodyPaddingRight = undefined;\n    }\n\n    if (previousBodyOverflowSetting !== undefined) {\n      document.body.style.overflow = previousBodyOverflowSetting; // Restore previousBodyOverflowSetting to undefined\n      // so setOverflowHidden knows it can be set again.\n\n      previousBodyOverflowSetting = undefined;\n    }\n  });\n}; // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\n\n\nvar isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {\n  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;\n};\n\nvar handleScroll = function handleScroll(event, targetElement) {\n  var clientY = event.targetTouches[0].clientY - initialClientY;\n\n  if (allowTouchMove(event.target)) {\n    return false;\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll\n    return preventDefault(event);\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the top of its scroll\n    return preventDefault(event);\n  }\n\n  event.stopPropagation();\n  return true;\n};\n\nvar disableBodyScroll = function disableBodyScroll(targetElement, options) {\n  if (isIosDevice) {\n    // targetElement must be provided, and disableBodyScroll must not have been\n    // called on this targetElement before.\n    if (!targetElement) {\n      // eslint-disable-next-line no-console\n      console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');\n      return;\n    }\n\n    if (targetElement && !locks.some(function (lock) {\n      return lock.targetElement === targetElement;\n    })) {\n      var lock = {\n        targetElement: targetElement,\n        options: options || {}\n      };\n      locks = [].concat(_toConsumableArray(locks), [lock]);\n\n      targetElement.ontouchstart = function (event) {\n        if (event.targetTouches.length === 1) {\n          // detect single touch\n          initialClientY = event.targetTouches[0].clientY;\n        }\n      };\n\n      targetElement.ontouchmove = function (event) {\n        if (event.targetTouches.length === 1) {\n          // detect single touch\n          handleScroll(event, targetElement);\n        }\n      };\n\n      if (!documentListenerAdded) {\n        document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? {\n          passive: false\n        } : undefined);\n        documentListenerAdded = true;\n      }\n    }\n  } else {\n    setOverflowHidden(options);\n    var _lock = {\n      targetElement: targetElement,\n      options: options || {}\n    };\n    locks = [].concat(_toConsumableArray(locks), [_lock]);\n  }\n};\n\nexports.disableBodyScroll = disableBodyScroll;\n\nvar clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {\n  if (isIosDevice) {\n    // Clear all locks ontouchstart/ontouchmove handlers, and the references\n    locks.forEach(function (lock) {\n      lock.targetElement.ontouchstart = null;\n      lock.targetElement.ontouchmove = null;\n    });\n\n    if (documentListenerAdded) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : undefined);\n      documentListenerAdded = false;\n    }\n\n    locks = []; // Reset initial clientY\n\n    initialClientY = -1;\n  } else {\n    restoreOverflowSetting();\n    locks = [];\n  }\n};\n\nexports.clearAllBodyScrollLocks = clearAllBodyScrollLocks;\n\nvar enableBodyScroll = function enableBodyScroll(targetElement) {\n  if (isIosDevice) {\n    if (!targetElement) {\n      // eslint-disable-next-line no-console\n      console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');\n      return;\n    }\n\n    targetElement.ontouchstart = null;\n    targetElement.ontouchmove = null;\n    locks = locks.filter(function (lock) {\n      return lock.targetElement !== targetElement;\n    });\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? {\n        passive: false\n      } : undefined);\n      documentListenerAdded = false;\n    }\n  } else if (locks.length === 1 && locks[0].targetElement === targetElement) {\n    restoreOverflowSetting();\n    locks = [];\n  } else {\n    locks = locks.filter(function (lock) {\n      return lock.targetElement !== targetElement;\n    });\n  }\n};\n\nexports.enableBodyScroll = enableBodyScroll;\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectHover = {\n  update: function update() {\n    if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {\n      detectHover.hover = window.matchMedia('(hover: hover)').matches;\n      detectHover.none = window.matchMedia('(hover: none)').matches || window.matchMedia('(hover: on-demand)').matches;\n      detectHover.anyHover = window.matchMedia('(any-hover: hover)').matches;\n      detectHover.anyNone = window.matchMedia('(any-hover: none)').matches || window.matchMedia('(any-hover: on-demand)').matches;\n    }\n  }\n};\ndetectHover.update();\nexports.default = detectHover;\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _detectHover = _interopRequireDefault(require(\"detect-hover\"));\n\nvar _detectPointer = _interopRequireDefault(require(\"detect-pointer\"));\n\nvar _detectTouchEvents = _interopRequireDefault(require(\"detect-touch-events\"));\n\nvar _detectPassiveEvents = _interopRequireDefault(require(\"detect-passive-events\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * detectIt object structure\n * const detectIt = {\n *   deviceType: 'mouseOnly' / 'touchOnly' / 'hybrid',\n *   passiveEvents: boolean,\n *   hasTouch: boolean,\n *   hasMouse: boolean,\n *   maxTouchPoints: number,\n *   primaryHover: 'hover' / 'none',\n *   primaryPointer: 'fine' / 'coarse' / 'none',\n *   state: {\n *     detectHover,\n *     detectPointer,\n *     detectTouchEvents,\n *     detectPassiveEvents,\n *   },\n *   update() {...},\n * }\n */\nfunction determineDeviceType(hasTouch, anyHover, anyFine, state) {\n  // A hybrid device is one that both hasTouch and any input device can hover\n  // or has a fine pointer.\n  if (hasTouch && (anyHover || anyFine)) return 'hybrid'; // workaround for browsers that have the touch events api,\n  // and have implemented Level 4 media queries but not the\n  // hover and pointer media queries, so the tests are all false (notable Firefox)\n  // if it hasTouch, no pointer and hover support, and on an android assume it's touchOnly\n  // if it hasTouch, no pointer and hover support, and not on an android assume it's a hybrid\n\n  if (hasTouch && Object.keys(state.detectHover).filter(function (key) {\n    return key !== 'update';\n  }).every(function (key) {\n    return state.detectHover[key] === false;\n  }) && Object.keys(state.detectPointer).filter(function (key) {\n    return key !== 'update';\n  }).every(function (key) {\n    return state.detectPointer[key] === false;\n  })) {\n    if (window.navigator && /android/.test(window.navigator.userAgent.toLowerCase())) {\n      return 'touchOnly';\n    }\n\n    return 'hybrid';\n  } // In almost all cases a device that doesn’t support touch will have a mouse,\n  // but there may be rare exceptions. Note that it doesn’t work to do additional tests\n  // based on hover and pointer media queries as older browsers don’t support these.\n  // Essentially, 'mouseOnly' is the default.\n\n\n  return hasTouch ? 'touchOnly' : 'mouseOnly';\n}\n\nvar detectIt = {\n  state: {\n    detectHover: _detectHover.default,\n    detectPointer: _detectPointer.default,\n    detectTouchEvents: _detectTouchEvents.default,\n    detectPassiveEvents: _detectPassiveEvents.default\n  },\n  update: function update() {\n    detectIt.state.detectHover.update();\n    detectIt.state.detectPointer.update();\n    detectIt.state.detectTouchEvents.update();\n    detectIt.state.detectPassiveEvents.update();\n    detectIt.updateOnlyOwnProperties();\n  },\n  updateOnlyOwnProperties: function updateOnlyOwnProperties() {\n    if (typeof window !== 'undefined') {\n      detectIt.passiveEvents = detectIt.state.detectPassiveEvents.hasSupport || false;\n      detectIt.hasTouch = detectIt.state.detectTouchEvents.hasSupport || false;\n      detectIt.deviceType = determineDeviceType(detectIt.hasTouch, detectIt.state.detectHover.anyHover, detectIt.state.detectPointer.anyFine, detectIt.state);\n      detectIt.hasMouse = detectIt.deviceType !== 'touchOnly';\n      detectIt.primaryInput = detectIt.deviceType === 'mouseOnly' && 'mouse' || detectIt.deviceType === 'touchOnly' && 'touch' || // deviceType is hybrid:\n      detectIt.state.detectPointer.fine && 'mouse' || detectIt.state.detectPointer.coarse && 'touch' || // if there's no support for hover media queries but detectIt determined it's\n      // a hybrid  device, then assume it's a mouse first device\n      'mouse'; // issue with Windows Chrome on hybrid devices starting in version 59 where\n      // media queries represent a touch only device, so if the browser is an\n      // affected Windows Chrome version and hasTouch,\n      // then assume it's a hybrid with primaryInput mouse\n      // note that version 62 of Chrome fixes this issue\n      // see https://github.com/rafrex/detect-it/issues/8\n\n      var inVersionRange = function inVersionRange(version) {\n        return version >= 59 && version < 62;\n      };\n\n      var isAffectedWindowsChromeVersion = /windows/.test(window.navigator.userAgent.toLowerCase()) && /chrome/.test(window.navigator.userAgent.toLowerCase()) && inVersionRange(parseInt(/Chrome\\/([0-9.]+)/.exec(navigator.userAgent)[1], 10));\n\n      if (isAffectedWindowsChromeVersion && detectIt.hasTouch) {\n        detectIt.deviceType = 'hybrid';\n        detectIt.hasMouse = true;\n        detectIt.primaryInput = 'mouse';\n      }\n    }\n  }\n};\ndetectIt.updateOnlyOwnProperties();\nvar _default = detectIt;\nexports.default = _default;\n\n},{\"detect-hover\":2,\"detect-passive-events\":4,\"detect-pointer\":5,\"detect-touch-events\":6}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // adapted from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n\nvar detectPassiveEvents = {\n  update: function update() {\n    if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n      var passive = false;\n      var options = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          passive = true;\n        }\n      }); // note: have to set and remove a no-op listener instead of null\n      // (which was used previously), becasue Edge v15 throws an error\n      // when providing a null callback.\n      // https://github.com/rafrex/detect-passive-events/pull/3\n\n      var noop = function noop() {};\n\n      window.addEventListener('testPassiveEventSupport', noop, options);\n      window.removeEventListener('testPassiveEventSupport', noop, options);\n      detectPassiveEvents.hasSupport = passive;\n    }\n  }\n};\ndetectPassiveEvents.update();\nexports.default = detectPassiveEvents;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectPointer = {\n  update: function update() {\n    if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {\n      detectPointer.fine = window.matchMedia('(pointer: fine)').matches;\n      detectPointer.coarse = window.matchMedia('(pointer: coarse)').matches;\n      detectPointer.none = window.matchMedia('(pointer: none)').matches;\n      detectPointer.anyFine = window.matchMedia('(any-pointer: fine)').matches;\n      detectPointer.anyCoarse = window.matchMedia('(any-pointer: coarse)').matches;\n      detectPointer.anyNone = window.matchMedia('(any-pointer: none)').matches;\n    }\n  }\n};\ndetectPointer.update();\nexports.default = detectPointer;\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar detectTouchEvents = {\n  update: function update() {\n    if (typeof window !== 'undefined') {\n      detectTouchEvents.hasSupport = 'ontouchstart' in window;\n      detectTouchEvents.browserSupportsApi = Boolean(window.TouchEvent);\n    }\n  }\n};\ndetectTouchEvents.update();\nexports.default = detectTouchEvents;\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\n/*global define:false */\n\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.3\n * @url craig.is/killing/mice\n */\n(function (window, document, undefined) {\n  // Check if mousetrap is used inside browser, if not, return\n  if (!window) {\n    return;\n  }\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n\n\n  var _MAP = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'ins',\n    46: 'del',\n    91: 'meta',\n    93: 'meta',\n    224: 'meta'\n  };\n  /**\n   * mapping for special characters so they can support\n   *\n   * this dictionary is only used incase you want to bind a\n   * keyup or keydown event to one of these keys\n   *\n   * @type {Object}\n   */\n\n  var _KEYCODE_MAP = {\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n  /**\n   * this is a mapping of keys that require shift on a US keypad\n   * back to the non shift equivelents\n   *\n   * this is so you can use keyup events with these keys\n   *\n   * note that this will only work reliably on US keyboards\n   *\n   * @type {Object}\n   */\n\n  var _SHIFT_MAP = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\\\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\'\n  };\n  /**\n   * this is a list of special strings you can use to map\n   * to modifier keys when you specify your keyboard shortcuts\n   *\n   * @type {Object}\n   */\n\n  var _SPECIAL_ALIASES = {\n    'option': 'alt',\n    'command': 'meta',\n    'return': 'enter',\n    'escape': 'esc',\n    'plus': '+',\n    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n  };\n  /**\n   * variable to store the flipped version of _MAP from above\n   * needed to check if we should use keypress or not when no action\n   * is specified\n   *\n   * @type {Object|undefined}\n   */\n\n  var _REVERSE_MAP;\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n\n\n  for (var i = 1; i < 20; ++i) {\n    _MAP[111 + i] = 'f' + i;\n  }\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n\n\n  for (i = 0; i <= 9; ++i) {\n    // This needs to use a string cause otherwise since 0 is falsey\n    // mousetrap will never fire for numpad 0 pressed as part of a keydown\n    // event.\n    //\n    // @see https://github.com/ccampbell/mousetrap/pull/258\n    _MAP[i + 96] = i.toString();\n  }\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n\n\n  function _addEvent(object, type, callback) {\n    if (object.addEventListener) {\n      object.addEventListener(type, callback, false);\n      return;\n    }\n\n    object.attachEvent('on' + type, callback);\n  }\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n\n\n  function _characterFromEvent(e) {\n    // for keypress events we should return the character as is\n    if (e.type == 'keypress') {\n      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume\n      // that we want the character to be lowercase.  this means if\n      // you accidentally have caps lock on then your key bindings\n      // will continue to work\n      //\n      // the only side effect that might not be desired is if you\n      // bind something like 'A' cause you want to trigger an\n      // event when capital A is pressed caps lock will no longer\n      // trigger the event.  shift+a will though.\n\n      if (!e.shiftKey) {\n        character = character.toLowerCase();\n      }\n\n      return character;\n    } // for non keypress events the special maps are needed\n\n\n    if (_MAP[e.which]) {\n      return _MAP[e.which];\n    }\n\n    if (_KEYCODE_MAP[e.which]) {\n      return _KEYCODE_MAP[e.which];\n    } // if it is not in the special map\n    // with keydown and keyup events the character seems to always\n    // come in as an uppercase character whether you are pressing shift\n    // or not.  we should make sure it is always lowercase for comparisons\n\n\n    return String.fromCharCode(e.which).toLowerCase();\n  }\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n\n\n  function _modifiersMatch(modifiers1, modifiers2) {\n    return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n\n\n  function _eventModifiers(e) {\n    var modifiers = [];\n\n    if (e.shiftKey) {\n      modifiers.push('shift');\n    }\n\n    if (e.altKey) {\n      modifiers.push('alt');\n    }\n\n    if (e.ctrlKey) {\n      modifiers.push('ctrl');\n    }\n\n    if (e.metaKey) {\n      modifiers.push('meta');\n    }\n\n    return modifiers;\n  }\n  /**\n   * prevents default for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n      return;\n    }\n\n    e.returnValue = false;\n  }\n  /**\n   * stops propogation for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n      return;\n    }\n\n    e.cancelBubble = true;\n  }\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  function _isModifier(key) {\n    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n\n\n  function _getReverseMap() {\n    if (!_REVERSE_MAP) {\n      _REVERSE_MAP = {};\n\n      for (var key in _MAP) {\n        // pull out the numeric keypad from here cause keypress should\n        // be able to detect the keys from the character\n        if (key > 95 && key < 112) {\n          continue;\n        }\n\n        if (_MAP.hasOwnProperty(key)) {\n          _REVERSE_MAP[_MAP[key]] = key;\n        }\n      }\n    }\n\n    return _REVERSE_MAP;\n  }\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n\n\n  function _pickBestAction(key, modifiers, action) {\n    // if no action was picked in we should try to pick the one\n    // that we think would work best for this key\n    if (!action) {\n      action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n    } // modifier keys don't work as expected with keypress,\n    // switch to keydown\n\n\n    if (action == 'keypress' && modifiers.length) {\n      action = 'keydown';\n    }\n\n    return action;\n  }\n  /**\n   * Converts from a string key combination to an array\n   *\n   * @param  {string} combination like \"command+shift+l\"\n   * @return {Array}\n   */\n\n\n  function _keysFromString(combination) {\n    if (combination === '+') {\n      return ['+'];\n    }\n\n    combination = combination.replace(/\\+{2}/g, '+plus');\n    return combination.split('+');\n  }\n  /**\n   * Gets info for a specific key combination\n   *\n   * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n   * @param  {string=} action\n   * @returns {Object}\n   */\n\n\n  function _getKeyInfo(combination, action) {\n    var keys;\n    var key;\n    var i;\n    var modifiers = []; // take the keys from this pattern and figure out what the actual\n    // pattern is all about\n\n    keys = _keysFromString(combination);\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i]; // normalize key names\n\n      if (_SPECIAL_ALIASES[key]) {\n        key = _SPECIAL_ALIASES[key];\n      } // if this is not a keypress event then we should\n      // be smart about using shift keys\n      // this will only work for US keyboards however\n\n\n      if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n        key = _SHIFT_MAP[key];\n        modifiers.push('shift');\n      } // if this key is a modifier then add it to the list of modifiers\n\n\n      if (_isModifier(key)) {\n        modifiers.push(key);\n      }\n    } // depending on what the key combination is\n    // we will try to pick the best event for it\n\n\n    action = _pickBestAction(key, modifiers, action);\n    return {\n      key: key,\n      modifiers: modifiers,\n      action: action\n    };\n  }\n\n  function _belongsTo(element, ancestor) {\n    if (element === null || element === document) {\n      return false;\n    }\n\n    if (element === ancestor) {\n      return true;\n    }\n\n    return _belongsTo(element.parentNode, ancestor);\n  }\n\n  function Mousetrap(targetElement) {\n    var self = this;\n    targetElement = targetElement || document;\n\n    if (!(self instanceof Mousetrap)) {\n      return new Mousetrap(targetElement);\n    }\n    /**\n     * element to attach key events to\n     *\n     * @type {Element}\n     */\n\n\n    self.target = targetElement;\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n\n    self._callbacks = {};\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n\n    self._directMap = {};\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n\n    var _sequenceLevels = {};\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n\n    var _resetTimer;\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n\n\n    var _ignoreNextKeyup = false;\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n\n    var _ignoreNextKeypress = false;\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n\n    var _nextExpectedAction = false;\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} doNotReset\n     * @returns void\n     */\n\n    function _resetSequences(doNotReset) {\n      doNotReset = doNotReset || {};\n      var activeSequences = false,\n          key;\n\n      for (key in _sequenceLevels) {\n        if (doNotReset[key]) {\n          activeSequences = true;\n          continue;\n        }\n\n        _sequenceLevels[key] = 0;\n      }\n\n      if (!activeSequences) {\n        _nextExpectedAction = false;\n      }\n    }\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {string=} sequenceName - name of the sequence we are looking for\n     * @param {string=} combination\n     * @param {number=} level\n     * @returns {Array}\n     */\n\n\n    function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n      var i;\n      var callback;\n      var matches = [];\n      var action = e.type; // if there are no events related to this keycode\n\n      if (!self._callbacks[character]) {\n        return [];\n      } // if a modifier key is coming up on its own we should allow it\n\n\n      if (action == 'keyup' && _isModifier(character)) {\n        modifiers = [character];\n      } // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n\n\n      for (i = 0; i < self._callbacks[character].length; ++i) {\n        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at\n        // the wrong level then move onto the next match\n\n        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n          continue;\n        } // if the action we are looking for doesn't match the action we got\n        // then we should keep going\n\n\n        if (action != callback.action) {\n          continue;\n        } // if this is a keypress event and the meta key and control key\n        // are not pressed that means that we need to only look at the\n        // character, otherwise check the modifiers as well\n        //\n        // chrome will not fire a keypress if meta or control is down\n        // safari will fire a keypress if meta or meta+shift is down\n        // firefox will fire a keypress if meta or control is down\n\n\n        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {\n          // when you bind a combination or sequence a second time it\n          // should overwrite the first one.  if a sequenceName or\n          // combination is specified in this call it does just that\n          //\n          // @todo make deleting its own method?\n          var deleteCombo = !sequenceName && callback.combo == combination;\n          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\n          if (deleteCombo || deleteSequence) {\n            self._callbacks[character].splice(i, 1);\n          }\n\n          matches.push(callback);\n        }\n      }\n\n      return matches;\n    }\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _fireCallback(callback, e, combo, sequence) {\n      // if this event should not happen stop here\n      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n        return;\n      }\n\n      if (callback(e, combo) === false) {\n        _preventDefault(e);\n\n        _stopPropagation(e);\n      }\n    }\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    self._handleKey = function (character, modifiers, e) {\n      var callbacks = _getMatches(character, modifiers, e);\n\n      var i;\n      var doNotReset = {};\n      var maxLevel = 0;\n      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\n      for (i = 0; i < callbacks.length; ++i) {\n        if (callbacks[i].seq) {\n          maxLevel = Math.max(maxLevel, callbacks[i].level);\n        }\n      } // loop through matching callbacks for this key event\n\n\n      for (i = 0; i < callbacks.length; ++i) {\n        // fire for all sequence callbacks\n        // this is because if for example you have multiple sequences\n        // bound such as \"g i\" and \"g t\" they both need to fire the\n        // callback for matching g cause otherwise you can only ever\n        // match the first one\n        if (callbacks[i].seq) {\n          // only fire callbacks for the maxLevel to prevent\n          // subsequences from also firing\n          //\n          // for example 'a option b' should not cause 'option b' to fire\n          // even though 'option b' is part of the other sequence\n          //\n          // any sequences that do not match here will be discarded\n          // below by the _resetSequences call\n          if (callbacks[i].level != maxLevel) {\n            continue;\n          }\n\n          processedSequenceCallback = true; // keep a list of which sequences were matches for later\n\n          doNotReset[callbacks[i].seq] = 1;\n\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\n          continue;\n        } // if there were no sequence matches but we are still here\n        // that means this is a regular match so we should fire that\n\n\n        if (!processedSequenceCallback) {\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n        }\n      } // if the key you pressed matches the type of sequence without\n      // being a modifier (ie \"keyup\" or \"keypress\") then we should\n      // reset all sequences that were not matched by this event\n      //\n      // this is so, for example, if you have the sequence \"h a t\" and you\n      // type \"h e a r t\" it does not match.  in this case the \"e\" will\n      // cause the sequence to reset\n      //\n      // modifier keys are ignored because you can have a sequence\n      // that contains modifiers such as \"enter ctrl+space\" and in most\n      // cases the modifier key will be pressed before the next key\n      //\n      // also if you have a sequence such as \"ctrl+b a\" then pressing the\n      // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n      //\n      // the \"keydown\" is expected when there is a modifier, but the\n      // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n      // after and that causes the sequence to reset\n      //\n      // we ignore keypresses in a sequence that directly follow a keydown\n      // for the same character\n\n\n      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\n      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n        _resetSequences(doNotReset);\n      }\n\n      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n    };\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _handleKeyEvent(e) {\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n      }\n\n      var character = _characterFromEvent(e); // no character found then stop\n\n\n      if (!character) {\n        return;\n      } // need to use === for the character check because the character can be 0\n\n\n      if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n      }\n\n      self.handleKey(character, _eventModifiers(e), e);\n    }\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n\n\n    function _resetSequenceTimer() {\n      clearTimeout(_resetTimer);\n      _resetTimer = setTimeout(_resetSequences, 1000);\n    }\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n\n\n    function _bindSequence(combo, keys, callback, action) {\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequenceLevels[combo] = 0;\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {string} nextAction\n       * @returns {Function}\n       */\n\n      function _increaseSequence(nextAction) {\n        return function () {\n          _nextExpectedAction = nextAction;\n          ++_sequenceLevels[combo];\n\n          _resetSequenceTimer();\n        };\n      }\n      /**\n       * wraps the specified callback inside of another function in order\n       * to reset all sequence counters as soon as this sequence is done\n       *\n       * @param {Event} e\n       * @returns void\n       */\n\n\n      function _callbackAndReset(e) {\n        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down\n        // or keypress.  this is so if you finish a sequence and\n        // release the key the final key will not trigger a keyup\n\n\n        if (action !== 'keyup') {\n          _ignoreNextKeyup = _characterFromEvent(e);\n        } // weird race condition if a sequence ends with the key\n        // another sequence begins with\n\n\n        setTimeout(_resetSequences, 10);\n      } // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      //\n      // if an action is specified in the original bind call then that will\n      // be used throughout.  otherwise we will pass the action that the\n      // next key in the sequence should match.  this allows a sequence\n      // to mix and match keypress and keydown events depending on which\n      // ones are better suited to the key provided\n\n\n      for (var i = 0; i < keys.length; ++i) {\n        var isFinal = i + 1 === keys.length;\n        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\n        _bindSingle(keys[i], wrappedCallback, action, combo, i);\n      }\n    }\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequenceName - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n\n\n    function _bindSingle(combination, callback, action, sequenceName, level) {\n      // store a direct mapped reference for use with Mousetrap.trigger\n      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space\n\n      combination = combination.replace(/\\s+/g, ' ');\n      var sequence = combination.split(' ');\n      var info; // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n\n      if (sequence.length > 1) {\n        _bindSequence(combination, sequence, callback, action);\n\n        return;\n      }\n\n      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time\n      // a callback is added for this key\n\n      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one\n\n      _getMatches(info.key, info.modifiers, {\n        type: info.action\n      }, sequenceName, combination, level); // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n\n\n      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n        callback: callback,\n        modifiers: info.modifiers,\n        action: info.action,\n        seq: sequenceName,\n        level: level,\n        combo: combination\n      });\n    }\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n\n\n    self._bindMultiple = function (combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n        _bindSingle(combinations[i], callback, action);\n      }\n    }; // start!\n\n\n    _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keyup', _handleKeyEvent);\n  }\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.bind = function (keys, callback, action) {\n    var self = this;\n    keys = keys instanceof Array ? keys : [keys];\n\n    self._bindMultiple.call(self, keys, callback, action);\n\n    return self;\n  };\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.unbind = function (keys, action) {\n    var self = this;\n    return self.bind.call(self, keys, function () {}, action);\n  };\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.trigger = function (keys, action) {\n    var self = this;\n\n    if (self._directMap[keys + ':' + action]) {\n      self._directMap[keys + ':' + action]({}, keys);\n    }\n\n    return self;\n  };\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.reset = function () {\n    var self = this;\n    self._callbacks = {};\n    self._directMap = {};\n    return self;\n  };\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n\n\n  Mousetrap.prototype.stopCallback = function (e, element) {\n    var self = this; // if the element has the class \"mousetrap\" then no need to stop\n\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    if (_belongsTo(element, self.target)) {\n      return false;\n    } // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n    // not the initial event target in the shadow tree. Note that not all events cross the\n    // shadow boundary.\n    // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n    // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event\n    // target cannot be obtained.\n\n\n    if ('composedPath' in e && typeof e.composedPath === 'function') {\n      // For open shadow trees, update `element` so that the following check works.\n      var initialEventTarget = e.composedPath()[0];\n\n      if (initialEventTarget !== e.target) {\n        element = initialEventTarget;\n      }\n    } // stop for input, select, and textarea\n\n\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  };\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n\n\n  Mousetrap.prototype.handleKey = function () {\n    var self = this;\n    return self._handleKey.apply(self, arguments);\n  };\n  /**\n   * allow custom key mappings\n   */\n\n\n  Mousetrap.addKeycodes = function (object) {\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        _MAP[key] = object[key];\n      }\n    }\n\n    _REVERSE_MAP = null;\n  };\n  /**\n   * Init the global mousetrap functions\n   *\n   * This method is needed to allow the global mousetrap functions to work\n   * now that mousetrap is a constructor function.\n   */\n\n\n  Mousetrap.init = function () {\n    var documentMousetrap = Mousetrap(document);\n\n    for (var method in documentMousetrap) {\n      if (method.charAt(0) !== '_') {\n        Mousetrap[method] = function (method) {\n          return function () {\n            return documentMousetrap[method].apply(documentMousetrap, arguments);\n          };\n        }(method);\n      }\n    }\n  };\n\n  Mousetrap.init(); // expose mousetrap to the global object\n\n  window.Mousetrap = Mousetrap; // expose as a common js module\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Mousetrap;\n  } // expose mousetrap as an AMD module\n\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return Mousetrap;\n    });\n  }\n})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);\n\n},{}],8:[function(require,module,exports){\n\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.pell = {});\n})(void 0, function (exports) {\n  'use strict';\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var defaultParagraphSeparatorString = 'defaultParagraphSeparator';\n  var formatBlock = 'formatBlock';\n\n  var addEventListener = function addEventListener(parent, type, listener) {\n    return parent.addEventListener(type, listener);\n  };\n\n  var appendChild = function appendChild(parent, child) {\n    return parent.appendChild(child);\n  };\n\n  var createElement = function createElement(tag) {\n    return document.createElement(tag);\n  };\n\n  var queryCommandState = function queryCommandState(command) {\n    return document.queryCommandState(command);\n  };\n\n  var queryCommandValue = function queryCommandValue(command) {\n    return document.queryCommandValue(command);\n  };\n\n  var exec = function exec(command) {\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return document.execCommand(command, false, value);\n  };\n\n  var defaultActions = {\n    bold: {\n      icon: '<b>B</b>',\n      title: 'Bold',\n      state: function state() {\n        return queryCommandState('bold');\n      },\n      result: function result() {\n        return exec('bold');\n      }\n    },\n    italic: {\n      icon: '<i>I</i>',\n      title: 'Italic',\n      state: function state() {\n        return queryCommandState('italic');\n      },\n      result: function result() {\n        return exec('italic');\n      }\n    },\n    underline: {\n      icon: '<u>U</u>',\n      title: 'Underline',\n      state: function state() {\n        return queryCommandState('underline');\n      },\n      result: function result() {\n        return exec('underline');\n      }\n    },\n    strikethrough: {\n      icon: '<strike>S</strike>',\n      title: 'Strike-through',\n      state: function state() {\n        return queryCommandState('strikeThrough');\n      },\n      result: function result() {\n        return exec('strikeThrough');\n      }\n    },\n    heading1: {\n      icon: '<b>H<sub>1</sub></b>',\n      title: 'Heading 1',\n      result: function result() {\n        return exec(formatBlock, '<h1>');\n      }\n    },\n    heading2: {\n      icon: '<b>H<sub>2</sub></b>',\n      title: 'Heading 2',\n      result: function result() {\n        return exec(formatBlock, '<h2>');\n      }\n    },\n    paragraph: {\n      icon: '&#182;',\n      title: 'Paragraph',\n      result: function result() {\n        return exec(formatBlock, '<p>');\n      }\n    },\n    quote: {\n      icon: '&#8220; &#8221;',\n      title: 'Quote',\n      result: function result() {\n        return exec(formatBlock, '<blockquote>');\n      }\n    },\n    olist: {\n      icon: '&#35;',\n      title: 'Ordered List',\n      result: function result() {\n        return exec('insertOrderedList');\n      }\n    },\n    ulist: {\n      icon: '&#8226;',\n      title: 'Unordered List',\n      result: function result() {\n        return exec('insertUnorderedList');\n      }\n    },\n    code: {\n      icon: '&lt;/&gt;',\n      title: 'Code',\n      result: function result() {\n        return exec(formatBlock, '<pre>');\n      }\n    },\n    line: {\n      icon: '&#8213;',\n      title: 'Horizontal Line',\n      result: function result() {\n        return exec('insertHorizontalRule');\n      }\n    },\n    link: {\n      icon: '&#128279;',\n      title: 'Link',\n      result: function result() {\n        var url = window.prompt('Enter the link URL');\n        if (url) exec('createLink', url);\n      }\n    },\n    image: {\n      icon: '&#128247;',\n      title: 'Image',\n      result: function result() {\n        var url = window.prompt('Enter the image URL');\n        if (url) exec('insertImage', url);\n      }\n    }\n  };\n  var defaultClasses = {\n    actionbar: 'pell-actionbar',\n    button: 'pell-button',\n    content: 'pell-content',\n    selected: 'pell-button-selected'\n  };\n\n  var init = function init(settings) {\n    var actions = settings.actions ? settings.actions.map(function (action) {\n      if (typeof action === 'string') return defaultActions[action];else if (defaultActions[action.name]) return _extends({}, defaultActions[action.name], action);\n      return action;\n    }) : Object.keys(defaultActions).map(function (action) {\n      return defaultActions[action];\n    });\n\n    var classes = _extends({}, defaultClasses, settings.classes);\n\n    var defaultParagraphSeparator = settings[defaultParagraphSeparatorString] || 'div';\n    var actionbar = createElement('div');\n    actionbar.className = classes.actionbar;\n    appendChild(settings.element, actionbar);\n    var content = settings.element.content = createElement('div');\n    content.contentEditable = true;\n    content.className = classes.content;\n\n    content.oninput = function (_ref) {\n      var firstChild = _ref.target.firstChild;\n      if (firstChild && firstChild.nodeType === 3) exec(formatBlock, '<' + defaultParagraphSeparator + '>');else if (content.innerHTML === '<br>') content.innerHTML = '';\n      settings.onChange(content.innerHTML);\n    };\n\n    content.onkeydown = function (event) {\n      if (event.key === 'Enter' && queryCommandValue(formatBlock) === 'blockquote') {\n        setTimeout(function () {\n          return exec(formatBlock, '<' + defaultParagraphSeparator + '>');\n        }, 0);\n      }\n    };\n\n    appendChild(settings.element, content);\n    actions.forEach(function (action) {\n      var button = createElement('button');\n      button.className = classes.button;\n      button.innerHTML = action.icon;\n      button.title = action.title;\n      button.setAttribute('type', 'button');\n\n      button.onclick = function () {\n        return action.result() && content.focus();\n      };\n\n      if (action.state) {\n        var handler = function handler() {\n          return button.classList[action.state() ? 'add' : 'remove'](classes.selected);\n        };\n\n        addEventListener(content, 'keyup', handler);\n        addEventListener(content, 'mouseup', handler);\n        addEventListener(button, 'click', handler);\n      }\n\n      appendChild(actionbar, button);\n    });\n    if (settings.styleWithCSS) exec('styleWithCSS');\n    exec(defaultParagraphSeparatorString, defaultParagraphSeparator);\n    return settings.element;\n  };\n\n  var pell = {\n    exec: exec,\n    init: init\n  };\n  exports.exec = exec;\n  exports.init = init;\n  exports['default'] = pell;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});\n\n},{}],9:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], function () {\n      return factory(root);\n    });\n  } else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') {\n    module.exports = factory(root);\n  } else {\n    root.SmoothScroll = factory(root);\n  }\n})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : void 0, function (window) {\n  'use strict'; //\n  // Default settings\n  //\n\n  var defaults = {\n    // Selectors\n    ignore: '[data-scroll-ignore]',\n    header: null,\n    topOnEmptyHash: true,\n    // Speed & Duration\n    speed: 500,\n    speedAsDuration: false,\n    durationMax: null,\n    durationMin: null,\n    clip: true,\n    offset: 0,\n    // Easing\n    easing: 'easeInOutCubic',\n    customEasing: null,\n    // History\n    updateURL: true,\n    popstate: true,\n    // Custom Events\n    emitEvents: true\n  }; //\n  // Utility Methods\n  //\n\n  /**\n   * Check if browser supports required methods\n   * @return {Boolean} Returns true if all required methods are supported\n   */\n\n  var supports = function supports() {\n    return 'querySelector' in document && 'addEventListener' in window && 'requestAnimationFrame' in window && 'closest' in window.Element.prototype;\n  };\n  /**\n   * Merge two or more objects together.\n   * @param   {Object}   objects  The objects to merge together\n   * @returns {Object}            Merged values of defaults and options\n   */\n\n\n  var extend = function extend() {\n    var merged = {};\n    Array.prototype.forEach.call(arguments, function (obj) {\n      for (var key in obj) {\n        if (!obj.hasOwnProperty(key)) return;\n        merged[key] = obj[key];\n      }\n    });\n    return merged;\n  };\n  /**\n   * Check to see if user prefers reduced motion\n   * @param  {Object} settings Script settings\n   */\n\n\n  var reduceMotion = function reduceMotion(settings) {\n    if ('matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Get the height of an element.\n   * @param  {Node} elem The element to get the height of\n   * @return {Number}    The element's height in pixels\n   */\n\n\n  var getHeight = function getHeight(elem) {\n    return parseInt(window.getComputedStyle(elem).height, 10);\n  };\n  /**\n   * Decode a URI, with error check\n   * @param  {String} hash The URI to decode\n   * @return {String}      A decoded URI (or the original string if an error is thrown)\n   */\n\n\n  var decode = function decode(hash) {\n    var decoded;\n\n    try {\n      decoded = decodeURIComponent(hash);\n    } catch (e) {\n      decoded = hash;\n    }\n\n    return decoded;\n  };\n  /**\n   * Escape special characters for use with querySelector\n   * @author Mathias Bynens\n   * @link https://github.com/mathiasbynens/CSS.escape\n   * @param {String} id The anchor ID to escape\n   */\n\n\n  var escapeCharacters = function escapeCharacters(id) {\n    // Remove leading hash\n    if (id.charAt(0) === '#') {\n      id = id.substr(1);\n    }\n\n    var string = String(id);\n    var length = string.length;\n    var index = -1;\n    var codeUnit;\n    var result = '';\n    var firstCodeUnit = string.charCodeAt(0);\n\n    while (++index < length) {\n      codeUnit = string.charCodeAt(index); // Note: there’s no need to special-case astral symbols, surrogate\n      // pairs, or lone surrogates.\n      // If the character is NULL (U+0000), then throw an\n      // `InvalidCharacterError` exception and terminate these steps.\n\n      if (codeUnit === 0x0000) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');\n      }\n\n      if ( // If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n      // U+007F, […]\n      codeUnit >= 0x0001 && codeUnit <= 0x001F || codeUnit == 0x007F || // If the character is the first character and is in the range [0-9]\n      // (U+0030 to U+0039), […]\n      index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 || // If the character is the second character and is in the range [0-9]\n      // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]\n      index === 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit === 0x002D) {\n        // http://dev.w3.org/csswg/cssom/#escape-a-character-as-code-point\n        result += '\\\\' + codeUnit.toString(16) + ' ';\n        continue;\n      } // If the character is not handled by one of the above rules and is\n      // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or\n      // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to\n      // U+005A), or [a-z] (U+0061 to U+007A), […]\n\n\n      if (codeUnit >= 0x0080 || codeUnit === 0x002D || codeUnit === 0x005F || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005A || codeUnit >= 0x0061 && codeUnit <= 0x007A) {\n        // the character itself\n        result += string.charAt(index);\n        continue;\n      } // Otherwise, the escaped character.\n      // http://dev.w3.org/csswg/cssom/#escape-a-character\n\n\n      result += '\\\\' + string.charAt(index);\n    } // Return sanitized hash\n\n\n    var hash;\n\n    try {\n      hash = decodeURIComponent('#' + result);\n    } catch (e) {\n      hash = '#' + result;\n    }\n\n    return hash;\n  };\n  /**\n   * Calculate the easing pattern\n   * @link https://gist.github.com/gre/1650294\n   * @param {String} type Easing pattern\n   * @param {Number} time Time animation should take to complete\n   * @returns {Number}\n   */\n\n\n  var easingPattern = function easingPattern(settings, time) {\n    var pattern; // Default Easing Patterns\n\n    if (settings.easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\n\n    if (settings.easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\n\n    if (settings.easing === 'easeInOutQuad') pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\n\n    if (settings.easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\n\n    if (settings.easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\n\n    if (settings.easing === 'easeInOutCubic') pattern = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\n\n    if (settings.easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\n\n    if (settings.easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\n\n    if (settings.easing === 'easeInOutQuart') pattern = time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\n\n    if (settings.easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\n\n    if (settings.easing === 'easeOutQuint') pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\n\n    if (settings.easing === 'easeInOutQuint') pattern = time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\n    // Custom Easing Patterns\n\n    if (!!settings.customEasing) pattern = settings.customEasing(time);\n    return pattern || time; // no easing, no acceleration\n  };\n  /**\n   * Determine the document's height\n   * @returns {Number}\n   */\n\n\n  var getDocumentHeight = function getDocumentHeight() {\n    return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);\n  };\n  /**\n   * Calculate how far to scroll\n   * Clip support added by robjtede - https://github.com/cferdinandi/smooth-scroll/issues/405\n   * @param {Element} anchor       The anchor element to scroll to\n   * @param {Number}  headerHeight Height of a fixed header, if any\n   * @param {Number}  offset       Number of pixels by which to offset scroll\n   * @param {Boolean} clip         If true, adjust scroll distance to prevent abrupt stops near the bottom of the page\n   * @returns {Number}\n   */\n\n\n  var getEndLocation = function getEndLocation(anchor, headerHeight, offset, clip) {\n    var location = 0;\n\n    if (anchor.offsetParent) {\n      do {\n        location += anchor.offsetTop;\n        anchor = anchor.offsetParent;\n      } while (anchor);\n    }\n\n    location = Math.max(location - headerHeight - offset, 0);\n\n    if (clip) {\n      location = Math.min(location, getDocumentHeight() - window.innerHeight);\n    }\n\n    return location;\n  };\n  /**\n   * Get the height of the fixed header\n   * @param  {Node}   header The header\n   * @return {Number}        The height of the header\n   */\n\n\n  var getHeaderHeight = function getHeaderHeight(header) {\n    return !header ? 0 : getHeight(header) + header.offsetTop;\n  };\n  /**\n   * Calculate the speed to use for the animation\n   * @param  {Number} distance The distance to travel\n   * @param  {Object} settings The plugin settings\n   * @return {Number}          How fast to animate\n   */\n\n\n  var getSpeed = function getSpeed(distance, settings) {\n    var speed = settings.speedAsDuration ? settings.speed : Math.abs(distance / 1000 * settings.speed);\n    if (settings.durationMax && speed > settings.durationMax) return settings.durationMax;\n    if (settings.durationMin && speed < settings.durationMin) return settings.durationMin;\n    return speed;\n  };\n  /**\n   * Update the URL\n   * @param  {Node}    anchor  The anchor that was scrolled to\n   * @param  {Boolean} isNum   If true, anchor is a number\n   * @param  {Object}  options Settings for Smooth Scroll\n   */\n\n\n  var updateURL = function updateURL(anchor, isNum, options) {\n    // Bail if the anchor is a number\n    if (isNum) return; // Verify that pushState is supported and the updateURL option is enabled\n\n    if (!history.pushState || !options.updateURL) return; // Update URL\n\n    history.pushState({\n      smoothScroll: JSON.stringify(options),\n      anchor: anchor.id\n    }, document.title, anchor === document.documentElement ? '#top' : '#' + anchor.id);\n  };\n  /**\n   * Bring the anchored element into focus\n   * @param {Node}     anchor      The anchor element\n   * @param {Number}   endLocation The end location to scroll to\n   * @param {Boolean}  isNum       If true, scroll is to a position rather than an element\n   */\n\n\n  var adjustFocus = function adjustFocus(anchor, endLocation, isNum) {\n    // Is scrolling to top of page, blur\n    if (anchor === 0) {\n      document.body.focus();\n    } // Don't run if scrolling to a number on the page\n\n\n    if (isNum) return; // Otherwise, bring anchor element into focus\n\n    anchor.focus();\n\n    if (document.activeElement !== anchor) {\n      anchor.setAttribute('tabindex', '-1');\n      anchor.focus();\n      anchor.style.outline = 'none';\n    }\n\n    window.scrollTo(0, endLocation);\n  };\n  /**\n   * Emit a custom event\n   * @param  {String} type    The event type\n   * @param  {Object} options The settings object\n   * @param  {Node}   anchor  The anchor element\n   * @param  {Node}   toggle  The toggle element\n   */\n\n\n  var emitEvent = function emitEvent(type, options, anchor, toggle) {\n    if (!options.emitEvents || typeof window.CustomEvent !== 'function') return;\n    var event = new CustomEvent(type, {\n      bubbles: true,\n      detail: {\n        anchor: anchor,\n        toggle: toggle\n      }\n    });\n    document.dispatchEvent(event);\n  }; //\n  // SmoothScroll Constructor\n  //\n\n\n  var SmoothScroll = function SmoothScroll(selector, options) {\n    //\n    // Variables\n    //\n    var smoothScroll = {}; // Object for public APIs\n\n    var settings, anchor, toggle, fixedHeader, headerHeight, eventTimeout, animationInterval; //\n    // Methods\n    //\n\n    /**\n     * Cancel a scroll-in-progress\n     */\n\n    smoothScroll.cancelScroll = function (noEvent) {\n      cancelAnimationFrame(animationInterval);\n      animationInterval = null;\n      if (noEvent) return;\n      emitEvent('scrollCancel', settings);\n    };\n    /**\n     * Start/stop the scrolling animation\n     * @param {Node|Number} anchor  The element or position to scroll to\n     * @param {Element}     toggle  The element that toggled the scroll event\n     * @param {Object}      options\n     */\n\n\n    smoothScroll.animateScroll = function (anchor, toggle, options) {\n      // Local settings\n      var _settings = extend(settings || defaults, options || {}); // Merge user options with defaults\n      // Selectors and variables\n\n\n      var isNum = Object.prototype.toString.call(anchor) === '[object Number]' ? true : false;\n      var anchorElem = isNum || !anchor.tagName ? null : anchor;\n      if (!isNum && !anchorElem) return;\n      var startLocation = window.pageYOffset; // Current location on the page\n\n      if (_settings.header && !fixedHeader) {\n        // Get the fixed header if not already set\n        fixedHeader = document.querySelector(_settings.header);\n      }\n\n      if (!headerHeight) {\n        // Get the height of a fixed header if one exists and not already set\n        headerHeight = getHeaderHeight(fixedHeader);\n      }\n\n      var endLocation = isNum ? anchor : getEndLocation(anchorElem, headerHeight, parseInt(typeof _settings.offset === 'function' ? _settings.offset(anchor, toggle) : _settings.offset, 10), _settings.clip); // Location to scroll to\n\n      var distance = endLocation - startLocation; // distance to travel\n\n      var documentHeight = getDocumentHeight();\n      var timeLapsed = 0;\n      var speed = getSpeed(distance, _settings);\n      var start, percentage, position;\n      /**\n       * Stop the scroll animation when it reaches its target (or the bottom/top of page)\n       * @param {Number} position Current position on the page\n       * @param {Number} endLocation Scroll to location\n       * @param {Number} animationInterval How much to scroll on this loop\n       */\n\n      var stopAnimateScroll = function stopAnimateScroll(position, endLocation) {\n        // Get the current location\n        var currentLocation = window.pageYOffset; // Check if the end location has been reached yet (or we've hit the end of the document)\n\n        if (position == endLocation || currentLocation == endLocation || (startLocation < endLocation && window.innerHeight + currentLocation) >= documentHeight) {\n          // Clear the animation timer\n          smoothScroll.cancelScroll(true); // Bring the anchored element into focus\n\n          adjustFocus(anchor, endLocation, isNum); // Emit a custom event\n\n          emitEvent('scrollStop', _settings, anchor, toggle); // Reset start\n\n          start = null;\n          animationInterval = null;\n          return true;\n        }\n      };\n      /**\n       * Loop scrolling animation\n       */\n\n\n      var loopAnimateScroll = function loopAnimateScroll(timestamp) {\n        if (!start) {\n          start = timestamp;\n        }\n\n        timeLapsed += timestamp - start;\n        percentage = timeLapsed / parseInt(speed, 10);\n        percentage = percentage > 1 ? 1 : percentage;\n        position = startLocation + distance * easingPattern(_settings, percentage);\n        window.scrollTo(0, Math.floor(position));\n\n        if (!stopAnimateScroll(position, endLocation)) {\n          animationInterval = window.requestAnimationFrame(loopAnimateScroll);\n          start = timestamp;\n        }\n      };\n      /**\n       * Reset position to fix weird iOS bug\n       * @link https://github.com/cferdinandi/smooth-scroll/issues/45\n       */\n\n\n      if (window.pageYOffset === 0) {\n        window.scrollTo(0, 0);\n      } // Update the URL\n\n\n      updateURL(anchor, isNum, _settings); // Emit a custom event\n\n      emitEvent('scrollStart', _settings, anchor, toggle); // Start scrolling animation\n\n      smoothScroll.cancelScroll(true);\n      window.requestAnimationFrame(loopAnimateScroll);\n    };\n    /**\n     * If smooth scroll element clicked, animate scroll\n     */\n\n\n    var clickHandler = function clickHandler(event) {\n      // Don't run if the user prefers reduced motion\n      if (reduceMotion(settings)) return; // Don't run if right-click or command/control + click\n\n      if (event.button !== 0 || event.metaKey || event.ctrlKey) return; // Check if event.target has closest() method\n      // By @totegi - https://github.com/cferdinandi/smooth-scroll/pull/401/\n\n      if (!('closest' in event.target)) return; // Check if a smooth scroll link was clicked\n\n      toggle = event.target.closest(selector);\n      if (!toggle || toggle.tagName.toLowerCase() !== 'a' || event.target.closest(settings.ignore)) return; // Only run if link is an anchor and points to the current page\n\n      if (toggle.hostname !== window.location.hostname || toggle.pathname !== window.location.pathname || !/#/.test(toggle.href)) return; // Get an escaped version of the hash\n\n      var hash = escapeCharacters(decode(toggle.hash)); // Get the anchored element\n\n      var anchor = settings.topOnEmptyHash && hash === '#' ? document.documentElement : document.querySelector(hash);\n      anchor = !anchor && hash === '#top' ? document.documentElement : anchor; // If anchored element exists, scroll to it\n\n      if (!anchor) return;\n      event.preventDefault();\n      smoothScroll.animateScroll(anchor, toggle);\n    };\n    /**\n     * Animate scroll on popstate events\n     */\n\n\n    var popstateHandler = function popstateHandler(event) {\n      // Stop if history.state doesn't exist (ex. if clicking on a broken anchor link).\n      // fixes `Cannot read property 'smoothScroll' of null` error getting thrown.\n      if (history.state === null) return; // Only run if state is a popstate record for this instantiation\n\n      if (!history.state.smoothScroll || history.state.smoothScroll !== JSON.stringify(settings)) return; // Only run if state includes an anchor\n\n      if (!history.state.anchor) return; // Get the anchor\n\n      var anchor = document.querySelector(escapeCharacters(decode(history.state.anchor)));\n      if (!anchor) return; // Animate scroll to anchor link\n\n      smoothScroll.animateScroll(anchor, null, {\n        updateURL: false\n      });\n    };\n    /**\n     * On window scroll and resize, only run events at a rate of 15fps for better performance\n     */\n\n\n    var resizeThrottler = function resizeThrottler(event) {\n      if (!eventTimeout) {\n        eventTimeout = setTimeout(function () {\n          eventTimeout = null; // Reset timeout\n\n          headerHeight = getHeaderHeight(fixedHeader); // Get the height of a fixed header if one exists\n        }, 66);\n      }\n    };\n    /**\n     * Destroy the current initialization.\n     */\n\n\n    smoothScroll.destroy = function () {\n      // If plugin isn't already initialized, stop\n      if (!settings) return; // Remove event listeners\n\n      document.removeEventListener('click', clickHandler, false);\n      window.removeEventListener('resize', resizeThrottler, false);\n      window.removeEventListener('popstate', popstateHandler, false); // Cancel any scrolls-in-progress\n\n      smoothScroll.cancelScroll(); // Reset variables\n\n      settings = null;\n      anchor = null;\n      toggle = null;\n      fixedHeader = null;\n      headerHeight = null;\n      eventTimeout = null;\n      animationInterval = null;\n    };\n    /**\n     * Initialize Smooth Scroll\n     * @param {Object} options User settings\n     */\n\n\n    smoothScroll.init = function (options) {\n      // feature test\n      if (!supports()) throw 'Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs.'; // Destroy any existing initializations\n\n      smoothScroll.destroy(); // Selectors and variables\n\n      settings = extend(defaults, options || {}); // Merge user options with defaults\n\n      fixedHeader = settings.header ? document.querySelector(settings.header) : null; // Get the fixed header\n\n      headerHeight = getHeaderHeight(fixedHeader); // When a toggle is clicked, run the click handler\n\n      document.addEventListener('click', clickHandler, false); // If window is resized and there's a fixed header, recalculate its size\n\n      if (fixedHeader) {\n        window.addEventListener('resize', resizeThrottler, false);\n      } // If updateURL and popState are enabled, listen for pop events\n\n\n      if (settings.updateURL && settings.popstate) {\n        window.addEventListener('popstate', popstateHandler, false);\n      }\n    }; //\n    // Initialize plugin\n    //\n\n\n    smoothScroll.init(options); //\n    // Public APIs\n    //\n\n    return smoothScroll;\n  };\n\n  return SmoothScroll;\n});\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],10:[function(require,module,exports){\n\"use strict\";\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar defaults = {\n  threshold: 50,\n  passive: false\n};\n\nvar Xwiper =\n/*#__PURE__*/\nfunction () {\n  function Xwiper(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Xwiper);\n\n    this.options = _objectSpread({}, defaults, options);\n    this.element = null;\n    this.touchStartX = 0;\n    this.touchStartY = 0;\n    this.touchEndX = 0;\n    this.touchEndY = 0;\n    this.onSwipeLeftAgent = null;\n    this.onSwipeRightAgent = null;\n    this.onSwipeUpAgent = null;\n    this.onSwipeDownAgent = null;\n    this.onTapAgent = null;\n    this.onTouchStart = this.onTouchStart.bind(this);\n    this.onTouchEnd = this.onTouchEnd.bind(this);\n    this.onSwipeLeft = this.onSwipeLeft.bind(this);\n    this.onSwipeRight = this.onSwipeRight.bind(this);\n    this.onSwipeUp = this.onSwipeUp.bind(this);\n    this.onSwipeDown = this.onSwipeDown.bind(this);\n    this.onTap = this.onTap.bind(this);\n    this.destroy = this.destroy.bind(this);\n    this.handleGesture = this.handleGesture.bind(this);\n    var eventOptions = this.options.passive ? {\n      passive: true\n    } : false;\n    this.element = element instanceof EventTarget ? element : document.querySelector(element);\n    this.element.addEventListener('touchstart', this.onTouchStart, eventOptions);\n    this.element.addEventListener('touchend', this.onTouchEnd, eventOptions);\n  }\n\n  _createClass(Xwiper, [{\n    key: \"onTouchStart\",\n    value: function onTouchStart(event) {\n      this.touchStartX = event.changedTouches[0].screenX;\n      this.touchStartY = event.changedTouches[0].screenY;\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(event) {\n      this.touchEndX = event.changedTouches[0].screenX;\n      this.touchEndY = event.changedTouches[0].screenY;\n      this.handleGesture();\n    }\n  }, {\n    key: \"onSwipeLeft\",\n    value: function onSwipeLeft(func) {\n      this.onSwipeLeftAgent = func;\n    }\n  }, {\n    key: \"onSwipeRight\",\n    value: function onSwipeRight(func) {\n      this.onSwipeRightAgent = func;\n    }\n  }, {\n    key: \"onSwipeUp\",\n    value: function onSwipeUp(func) {\n      this.onSwipeUpAgent = func;\n    }\n  }, {\n    key: \"onSwipeDown\",\n    value: function onSwipeDown(func) {\n      this.onSwipeDownAgent = func;\n    }\n  }, {\n    key: \"onTap\",\n    value: function onTap(func) {\n      this.onTapAgent = func;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.element.removeEventListener('touchstart', this.onTouchStart);\n      this.element.removeEventListener('touchend', this.onTouchEnd);\n    }\n  }, {\n    key: \"handleGesture\",\n    value: function handleGesture() {\n      /**\n       * swiped left\n       */\n      if (this.touchEndX + this.options.threshold <= this.touchStartX) {\n        this.onSwipeLeftAgent && this.onSwipeLeftAgent();\n        return 'swiped left';\n      }\n      /**\n       * swiped right\n       */\n\n\n      if (this.touchEndX - this.options.threshold >= this.touchStartX) {\n        this.onSwipeRightAgent && this.onSwipeRightAgent();\n        return 'swiped right';\n      }\n      /**\n       * swiped up\n       */\n\n\n      if (this.touchEndY + this.options.threshold <= this.touchStartY) {\n        this.onSwipeUpAgent && this.onSwipeUpAgent();\n        return 'swiped up';\n      }\n      /**\n       * swiped down\n       */\n\n\n      if (this.touchEndY - this.options.threshold >= this.touchStartY) {\n        this.onSwipeDownAgent && this.onSwipeDownAgent();\n        return 'swiped down';\n      }\n      /**\n       * tap\n       */\n\n\n      if (this.touchEndY === this.touchStartY) {\n        this.onTapAgent && this.onTapAgent();\n        return 'tap';\n      }\n    }\n  }]);\n\n  return Xwiper;\n}();\n\nmodule.exports = Xwiper;\n\n},{}],11:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// Native Javascript for Bootstrap 4 v2.0.26 | © dnp_theme | MIT-License\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD support:\n    define([], factory);\n  } else if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && module.exports) {\n    // CommonJS-like:\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    var bsn = factory();\n    root.Carousel = bsn.Carousel;\n    root.Modal = bsn.Modal;\n  }\n})(void 0, function () {\n  /* Native Javascript for Bootstrap 4 | Internal Utility Functions\n  ----------------------------------------------------------------*/\n  \"use strict\"; // globals\n\n  var globalObject = typeof global !== 'undefined' ? global : this || window,\n      DOC = document,\n      HTML = DOC.documentElement,\n      body = 'body',\n      // allow the library to be used in <head>\n  // Native Javascript for Bootstrap Global Object\n  BSN = globalObject.BSN = {},\n      supports = BSN.supports = [],\n      // function toggle attributes\n  dataToggle = 'data-toggle',\n      dataDismiss = 'data-dismiss',\n      dataSpy = 'data-spy',\n      dataRide = 'data-ride',\n      // components\n  stringAlert = 'Alert',\n      stringButton = 'Button',\n      stringCarousel = 'Carousel',\n      stringCollapse = 'Collapse',\n      stringDropdown = 'Dropdown',\n      stringModal = 'Modal',\n      stringPopover = 'Popover',\n      stringScrollSpy = 'ScrollSpy',\n      stringTab = 'Tab',\n      stringTooltip = 'Tooltip',\n      stringToast = 'Toast',\n      // options DATA API\n  dataAutohide = 'data-autohide',\n      databackdrop = 'data-backdrop',\n      dataKeyboard = 'data-keyboard',\n      dataTarget = 'data-target',\n      dataInterval = 'data-interval',\n      dataHeight = 'data-height',\n      dataPause = 'data-pause',\n      dataTitle = 'data-title',\n      dataOriginalTitle = 'data-original-title',\n      dataDismissible = 'data-dismissible',\n      dataTrigger = 'data-trigger',\n      dataAnimation = 'data-animation',\n      dataContainer = 'data-container',\n      dataPlacement = 'data-placement',\n      dataDelay = 'data-delay',\n      // option keys\n  backdrop = 'backdrop',\n      keyboard = 'keyboard',\n      delay = 'delay',\n      content = 'content',\n      target = 'target',\n      currentTarget = 'currentTarget',\n      interval = 'interval',\n      pause = 'pause',\n      animation = 'animation',\n      placement = 'placement',\n      container = 'container',\n      // box model\n  offsetTop = 'offsetTop',\n      offsetBottom = 'offsetBottom',\n      offsetLeft = 'offsetLeft',\n      scrollTop = 'scrollTop',\n      scrollLeft = 'scrollLeft',\n      clientWidth = 'clientWidth',\n      clientHeight = 'clientHeight',\n      offsetWidth = 'offsetWidth',\n      offsetHeight = 'offsetHeight',\n      innerWidth = 'innerWidth',\n      innerHeight = 'innerHeight',\n      scrollHeight = 'scrollHeight',\n      height = 'height',\n      // aria\n  ariaExpanded = 'aria-expanded',\n      ariaHidden = 'aria-hidden',\n      ariaSelected = 'aria-selected',\n      // event names\n  clickEvent = 'click',\n      hoverEvent = 'hover',\n      keydownEvent = 'keydown',\n      keyupEvent = 'keyup',\n      resizeEvent = 'resize',\n      scrollEvent = 'scroll',\n      // originalEvents\n  showEvent = 'show',\n      shownEvent = 'shown',\n      hideEvent = 'hide',\n      hiddenEvent = 'hidden',\n      closeEvent = 'close',\n      closedEvent = 'closed',\n      slidEvent = 'slid',\n      slideEvent = 'slide',\n      changeEvent = 'change',\n      // other\n  getAttribute = 'getAttribute',\n      setAttribute = 'setAttribute',\n      hasAttribute = 'hasAttribute',\n      createElement = 'createElement',\n      appendChild = 'appendChild',\n      innerHTML = 'innerHTML',\n      getElementsByTagName = 'getElementsByTagName',\n      preventDefault = 'preventDefault',\n      getBoundingClientRect = 'getBoundingClientRect',\n      querySelectorAll = 'querySelectorAll',\n      getElementsByCLASSNAME = 'getElementsByClassName',\n      getComputedStyle = 'getComputedStyle',\n      indexOf = 'indexOf',\n      parentNode = 'parentNode',\n      length = 'length',\n      toLowerCase = 'toLowerCase',\n      Transition = 'Transition',\n      Duration = 'Duration',\n      Webkit = 'Webkit',\n      style = 'style',\n      push = 'push',\n      tabindex = 'tabindex',\n      contains = 'contains',\n      active = 'active',\n      showClass = 'show',\n      collapsing = 'collapsing',\n      disabled = 'disabled',\n      loading = 'loading',\n      left = 'left',\n      right = 'right',\n      top = 'top',\n      bottom = 'bottom',\n      // tooltip / popover\n  mouseHover = 'onmouseleave' in DOC ? ['mouseenter', 'mouseleave'] : ['mouseover', 'mouseout'],\n      tipPositions = /\\b(top|bottom|left|right)+/,\n      // modal\n  modalOverlay = 0,\n      fixedTop = 'fixed-top',\n      fixedBottom = 'fixed-bottom',\n      // transitionEnd since 2.0.4\n  supportTransitions = Webkit + Transition in HTML[style] || Transition[toLowerCase]() in HTML[style],\n      transitionEndEvent = Webkit + Transition in HTML[style] ? Webkit[toLowerCase]() + Transition + 'End' : Transition[toLowerCase]() + 'end',\n      transitionDuration = Webkit + Duration in HTML[style] ? Webkit[toLowerCase]() + Transition + Duration : Transition[toLowerCase]() + Duration,\n      // touch since 2.0.26\n  touchEvents = {\n    start: 'touchstart',\n    end: 'touchend',\n    move: 'touchmove'\n  },\n      // set new focus element since 2.0.3\n  setFocus = function setFocus(element) {\n    element.focus ? element.focus() : element.setActive();\n  },\n      // class manipulation, since 2.0.0 requires polyfill.js\n  addClass = function addClass(element, classNAME) {\n    element.classList.add(classNAME);\n  },\n      removeClass = function removeClass(element, classNAME) {\n    element.classList.remove(classNAME);\n  },\n      hasClass = function hasClass(element, classNAME) {\n    // since 2.0.0\n    return element.classList[contains](classNAME);\n  },\n      // selection methods\n  getElementsByClassName = function getElementsByClassName(element, classNAME) {\n    // returns Array\n    return [].slice.call(element[getElementsByCLASSNAME](classNAME));\n  },\n      queryElement = function queryElement(selector, parent) {\n    var lookUp = parent ? parent : DOC;\n    return _typeof(selector) === 'object' ? selector : lookUp.querySelector(selector);\n  },\n      getClosest = function getClosest(element, selector) {\n    //element is the element and selector is for the closest parent element to find\n    // source http://gomakethings.com/climbing-up-and-down-the-dom-tree-with-vanilla-javascript/\n    var firstChar = selector.charAt(0),\n        selectorSubstring = selector.substr(1);\n\n    if (firstChar === '.') {\n      // If selector is a class\n      for (; element && element !== DOC; element = element[parentNode]) {\n        // Get closest match\n        if (queryElement(selector, element[parentNode]) !== null && hasClass(element, selectorSubstring)) {\n          return element;\n        }\n      }\n    } else if (firstChar === '#') {\n      // If selector is an ID\n      for (; element && element !== DOC; element = element[parentNode]) {\n        // Get closest match\n        if (element.id === selectorSubstring) {\n          return element;\n        }\n      }\n    }\n\n    return false;\n  },\n      // event attach jQuery style / trigger  since 1.2.0\n  on = function on(element, event, handler, options) {\n    element.addEventListener(event, handler, options ? options : false);\n  },\n      off = function off(element, event, handler, options) {\n    element.removeEventListener(event, handler, options ? options : false);\n  },\n      one = function one(element, event, handler) {\n    // one since 2.0.4\n    on(element, event, function handlerWrapper(e) {\n      handler(e);\n      off(element, event, handlerWrapper);\n    });\n  },\n      getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {\n    var duration = supportTransitions ? globalObject[getComputedStyle](element)[transitionDuration] : 0;\n    duration = parseFloat(duration);\n    duration = typeof duration === 'number' && !isNaN(duration) ? duration * 1000 : 0;\n    return duration; // we take a short offset to make sure we fire on the next frame after animation\n  },\n      emulateTransitionEnd = function emulateTransitionEnd(element, handler) {\n    // emulateTransitionEnd since 2.0.4\n    var called = 0,\n        duration = getTransitionDurationFromElement(element);\n    duration ? one(element, transitionEndEvent, function (e) {\n      !called && handler(e), called = 1;\n    }) : setTimeout(function () {\n      !called && handler(), called = 1;\n    }, 17);\n  },\n      bootstrapCustomEvent = function bootstrapCustomEvent(eventName, componentName, related) {\n    var OriginalCustomEvent = new CustomEvent(eventName + '.bs.' + componentName);\n    OriginalCustomEvent.relatedTarget = related;\n    this.dispatchEvent(OriginalCustomEvent);\n  },\n      // tooltip / popover stuff\n  getScroll = function getScroll() {\n    // also Affix and ScrollSpy uses it\n    return {\n      y: globalObject.pageYOffset || HTML[scrollTop],\n      x: globalObject.pageXOffset || HTML[scrollLeft]\n    };\n  },\n      styleTip = function styleTip(link, element, position, parent) {\n    // both popovers and tooltips (target,tooltip,placement,elementToAppendTo)\n    var elementDimensions = {\n      w: element[offsetWidth],\n      h: element[offsetHeight]\n    },\n        windowWidth = HTML[clientWidth] || DOC[body][clientWidth],\n        windowHeight = HTML[clientHeight] || DOC[body][clientHeight],\n        rect = link[getBoundingClientRect](),\n        scroll = parent === DOC[body] ? getScroll() : {\n      x: parent[offsetLeft] + parent[scrollLeft],\n      y: parent[offsetTop] + parent[scrollTop]\n    },\n        linkDimensions = {\n      w: rect[right] - rect[left],\n      h: rect[bottom] - rect[top]\n    },\n        isPopover = hasClass(element, 'popover'),\n        topPosition,\n        leftPosition,\n        arrow = queryElement('.arrow', element),\n        arrowTop,\n        arrowLeft,\n        arrowWidth,\n        arrowHeight,\n        halfTopExceed = rect[top] + linkDimensions.h / 2 - elementDimensions.h / 2 < 0,\n        halfLeftExceed = rect[left] + linkDimensions.w / 2 - elementDimensions.w / 2 < 0,\n        halfRightExceed = rect[left] + elementDimensions.w / 2 + linkDimensions.w / 2 >= windowWidth,\n        halfBottomExceed = rect[top] + elementDimensions.h / 2 + linkDimensions.h / 2 >= windowHeight,\n        topExceed = rect[top] - elementDimensions.h < 0,\n        leftExceed = rect[left] - elementDimensions.w < 0,\n        bottomExceed = rect[top] + elementDimensions.h + linkDimensions.h >= windowHeight,\n        rightExceed = rect[left] + elementDimensions.w + linkDimensions.w >= windowWidth; // recompute position\n\n    position = (position === left || position === right) && leftExceed && rightExceed ? top : position; // first, when both left and right limits are exceeded, we fall back to top|bottom\n\n    position = position === top && topExceed ? bottom : position;\n    position = position === bottom && bottomExceed ? top : position;\n    position = position === left && leftExceed ? right : position;\n    position = position === right && rightExceed ? left : position; // update tooltip/popover class\n\n    element.className[indexOf](position) === -1 && (element.className = element.className.replace(tipPositions, position)); // we check the computed width & height and update here\n\n    arrowWidth = arrow[offsetWidth];\n    arrowHeight = arrow[offsetHeight]; // apply styling to tooltip or popover\n\n    if (position === left || position === right) {\n      // secondary|side positions\n      if (position === left) {\n        // LEFT\n        leftPosition = rect[left] + scroll.x - elementDimensions.w - (isPopover ? arrowWidth : 0);\n      } else {\n        // RIGHT\n        leftPosition = rect[left] + scroll.x + linkDimensions.w;\n      } // adjust top and arrow\n\n\n      if (halfTopExceed) {\n        topPosition = rect[top] + scroll.y;\n        arrowTop = linkDimensions.h / 2 - arrowWidth;\n      } else if (halfBottomExceed) {\n        topPosition = rect[top] + scroll.y - elementDimensions.h + linkDimensions.h;\n        arrowTop = elementDimensions.h - linkDimensions.h / 2 - arrowWidth;\n      } else {\n        topPosition = rect[top] + scroll.y - elementDimensions.h / 2 + linkDimensions.h / 2;\n        arrowTop = elementDimensions.h / 2 - (isPopover ? arrowHeight * 0.9 : arrowHeight / 2);\n      }\n    } else if (position === top || position === bottom) {\n      // primary|vertical positions\n      if (position === top) {\n        // TOP\n        topPosition = rect[top] + scroll.y - elementDimensions.h - (isPopover ? arrowHeight : 0);\n      } else {\n        // BOTTOM\n        topPosition = rect[top] + scroll.y + linkDimensions.h;\n      } // adjust left | right and also the arrow\n\n\n      if (halfLeftExceed) {\n        leftPosition = 0;\n        arrowLeft = rect[left] + linkDimensions.w / 2 - arrowWidth;\n      } else if (halfRightExceed) {\n        leftPosition = windowWidth - elementDimensions.w * 1.01;\n        arrowLeft = elementDimensions.w - (windowWidth - rect[left]) + linkDimensions.w / 2 - arrowWidth / 2;\n      } else {\n        leftPosition = rect[left] + scroll.x - elementDimensions.w / 2 + linkDimensions.w / 2;\n        arrowLeft = elementDimensions.w / 2 - arrowWidth / 2;\n      }\n    } // apply style to tooltip/popover and its arrow\n\n\n    element[style][top] = topPosition + 'px';\n    element[style][left] = leftPosition + 'px';\n    arrowTop && (arrow[style][top] = arrowTop + 'px');\n    arrowLeft && (arrow[style][left] = arrowLeft + 'px');\n  };\n\n  BSN.version = '2.0.26';\n  /* Native Javascript for Bootstrap 4 | Carousel\n  ----------------------------------------------*/\n  // CAROUSEL DEFINITION\n  // ===================\n\n  var Carousel = function Carousel(element, options) {\n    // initialization element\n    element = queryElement(element); // set options\n\n    options = options || {}; // DATA API\n\n    var intervalAttribute = element[getAttribute](dataInterval),\n        intervalOption = options[interval],\n        intervalData = intervalAttribute === 'false' ? 0 : parseInt(intervalAttribute),\n        pauseData = element[getAttribute](dataPause) === hoverEvent || false,\n        keyboardData = element[getAttribute](dataKeyboard) === 'true' || false,\n        // strings\n    component = 'carousel',\n        paused = 'paused',\n        direction = 'direction',\n        carouselItem = 'carousel-item',\n        dataSlideTo = 'data-slide-to';\n    this[keyboard] = options[keyboard] === true || keyboardData;\n    this[pause] = options[pause] === hoverEvent || pauseData ? hoverEvent : false; // false / hover\n\n    this[interval] = typeof intervalOption === 'number' ? intervalOption : intervalOption === false || intervalData === 0 || intervalData === false ? 0 : isNaN(intervalData) ? 5000 // bootstrap carousel default interval\n    : intervalData; // bind, event targets\n\n    var self = this,\n        index = element.index = 0,\n        timer = element.timer = 0,\n        isSliding = false,\n        // isSliding prevents click event handlers when animation is running\n    isTouch = false,\n        startXPosition = null,\n        currentXPosition = null,\n        endXPosition = null,\n        // touch and event coordinates\n    slides = getElementsByClassName(element, carouselItem),\n        total = slides[length],\n        slideDirection = this[direction] = left,\n        leftArrow = getElementsByClassName(element, component + '-control-prev')[0],\n        rightArrow = getElementsByClassName(element, component + '-control-next')[0],\n        indicator = queryElement('.' + component + '-indicators', element),\n        indicators = indicator && indicator[getElementsByTagName](\"LI\") || []; // invalidate when not enough items\n\n    if (total < 2) {\n      return;\n    } // handlers\n\n\n    var pauseHandler = function pauseHandler() {\n      if (self[interval] !== false && !hasClass(element, paused)) {\n        addClass(element, paused);\n        !isSliding && (clearInterval(timer), timer = null);\n      }\n    },\n        resumeHandler = function resumeHandler() {\n      if (self[interval] !== false && hasClass(element, paused)) {\n        removeClass(element, paused);\n        !isSliding && (clearInterval(timer), timer = null);\n        !isSliding && self.cycle();\n      }\n    },\n        indicatorHandler = function indicatorHandler(e) {\n      e[preventDefault]();\n      if (isSliding) return;\n      var eventTarget = e[target]; // event target | the current active item\n\n      if (eventTarget && !hasClass(eventTarget, active) && eventTarget[getAttribute](dataSlideTo)) {\n        index = parseInt(eventTarget[getAttribute](dataSlideTo), 10);\n      } else {\n        return false;\n      }\n\n      self.slideTo(index); //Do the slide\n    },\n        controlsHandler = function controlsHandler(e) {\n      e[preventDefault]();\n      if (isSliding) return;\n      var eventTarget = e.currentTarget || e.srcElement;\n\n      if (eventTarget === rightArrow) {\n        index++;\n      } else if (eventTarget === leftArrow) {\n        index--;\n      }\n\n      self.slideTo(index); //Do the slide\n    },\n        keyHandler = function keyHandler(e) {\n      if (isSliding) return;\n\n      switch (e.which) {\n        case 39:\n          index++;\n          break;\n\n        case 37:\n          index--;\n          break;\n\n        default:\n          return;\n      }\n\n      self.slideTo(index); //Do the slide\n    },\n        // touch events\n    toggleTouchEvents = function toggleTouchEvents(toggle) {\n      toggle(element, touchEvents.move, touchMoveHandler, {\n        passive: true\n      });\n      toggle(element, touchEvents.end, touchEndHandler, {\n        passive: true\n      });\n    },\n        touchDownHandler = function touchDownHandler(e) {\n      if (isTouch) {\n        return;\n      }\n\n      startXPosition = parseInt(e.touches[0].pageX);\n\n      if (element.contains(e[target])) {\n        isTouch = true;\n        toggleTouchEvents(on);\n      }\n    },\n        touchMoveHandler = function touchMoveHandler(e) {\n      if (!isTouch) {\n        e.preventDefault();\n        return;\n      }\n\n      currentXPosition = parseInt(e.touches[0].pageX); //cancel touch if more than one touches detected\n\n      if (e.type === 'touchmove' && e.touches[length] > 1) {\n        e.preventDefault();\n        return false;\n      }\n    },\n        touchEndHandler = function touchEndHandler(e) {\n      if (!isTouch || isSliding) {\n        return;\n      }\n\n      endXPosition = currentXPosition || parseInt(e.touches[0].pageX);\n\n      if (isTouch) {\n        if ((!element.contains(e[target]) || !element.contains(e.relatedTarget)) && Math.abs(startXPosition - endXPosition) < 75) {\n          return false;\n        } else {\n          if (currentXPosition < startXPosition) {\n            index++;\n          } else if (currentXPosition > startXPosition) {\n            index--;\n          }\n\n          isTouch = false;\n          self.slideTo(index);\n        }\n\n        toggleTouchEvents(off);\n      }\n    },\n        // private methods\n    isElementInScrollRange = function isElementInScrollRange() {\n      var rect = element[getBoundingClientRect](),\n          viewportHeight = globalObject[innerHeight] || HTML[clientHeight];\n      return rect[top] <= viewportHeight && rect[bottom] >= 0; // bottom && top\n    },\n        setActivePage = function setActivePage(pageIndex) {\n      //indicators\n      for (var i = 0, icl = indicators[length]; i < icl; i++) {\n        removeClass(indicators[i], active);\n      }\n\n      if (indicators[pageIndex]) addClass(indicators[pageIndex], active);\n    }; // public methods\n\n\n    this.cycle = function () {\n      if (timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n\n      timer = setInterval(function () {\n        isElementInScrollRange() && (index++, self.slideTo(index));\n      }, this[interval]);\n    };\n\n    this.slideTo = function (next) {\n      if (isSliding) return; // when controled via methods, make sure to check again      \n\n      var activeItem = this.getActiveIndex(),\n          // the current active\n      orientation; // first return if we're on the same item #227\n\n      if (activeItem === next) {\n        return; // or determine slideDirection\n      } else if (activeItem < next || activeItem === 0 && next === total - 1) {\n        slideDirection = self[direction] = left; // next\n      } else if (activeItem > next || activeItem === total - 1 && next === 0) {\n        slideDirection = self[direction] = right; // prev\n      } // find the right next index \n\n\n      if (next < 0) {\n        next = total - 1;\n      } else if (next >= total) {\n        next = 0;\n      } // update index\n\n\n      index = next;\n      orientation = slideDirection === left ? 'next' : 'prev'; //determine type\n\n      bootstrapCustomEvent.call(element, slideEvent, component, slides[next]); // here we go with the slide\n\n      isSliding = true;\n      clearInterval(timer);\n      timer = null;\n      setActivePage(next);\n\n      if (supportTransitions && hasClass(element, 'slide')) {\n        addClass(slides[next], carouselItem + '-' + orientation);\n        slides[next][offsetWidth];\n        addClass(slides[next], carouselItem + '-' + slideDirection);\n        addClass(slides[activeItem], carouselItem + '-' + slideDirection);\n        emulateTransitionEnd(slides[next], function (e) {\n          var timeout = e && e[target] !== slides[next] ? e.elapsedTime * 1000 + 100 : 20;\n          isSliding && setTimeout(function () {\n            isSliding = false;\n            addClass(slides[next], active);\n            removeClass(slides[activeItem], active);\n            removeClass(slides[next], carouselItem + '-' + orientation);\n            removeClass(slides[next], carouselItem + '-' + slideDirection);\n            removeClass(slides[activeItem], carouselItem + '-' + slideDirection);\n            bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n\n            if (!DOC.hidden && self[interval] && !hasClass(element, paused)) {\n              self.cycle();\n            }\n          }, timeout);\n        });\n      } else {\n        addClass(slides[next], active);\n        slides[next][offsetWidth];\n        removeClass(slides[activeItem], active);\n        setTimeout(function () {\n          isSliding = false;\n\n          if (self[interval] && !hasClass(element, paused)) {\n            self.cycle();\n          }\n\n          bootstrapCustomEvent.call(element, slidEvent, component, slides[next]);\n        }, 100);\n      }\n    };\n\n    this.getActiveIndex = function () {\n      return slides[indexOf](getElementsByClassName(element, carouselItem + ' active')[0]) || 0;\n    }; // init\n\n\n    if (!(stringCarousel in element)) {\n      // prevent adding event handlers twice\n      if (self[pause] && self[interval]) {\n        on(element, mouseHover[0], pauseHandler, {\n          passive: true\n        });\n        on(element, mouseHover[1], resumeHandler, {\n          passive: true\n        });\n        on(element, touchEvents.start, pauseHandler, {\n          passive: true\n        });\n        on(element, touchEvents.end, resumeHandler, {\n          passive: true\n        });\n      }\n\n      slides[length] > 1 && on(element, touchEvents.start, touchDownHandler, {\n        passive: true\n      });\n      rightArrow && on(rightArrow, clickEvent, controlsHandler);\n      leftArrow && on(leftArrow, clickEvent, controlsHandler);\n      indicator && on(indicator, clickEvent, indicatorHandler);\n      self[keyboard] === true && on(globalObject, keydownEvent, keyHandler);\n    }\n\n    if (self.getActiveIndex() < 0) {\n      slides[length] && addClass(slides[0], active);\n      indicators[length] && setActivePage(0);\n    }\n\n    if (self[interval]) {\n      self.cycle();\n    }\n\n    element[stringCarousel] = self;\n  }; // CAROUSEL DATA API\n  // =================\n\n\n  supports[push]([stringCarousel, Carousel, '[' + dataRide + '=\"carousel\"]']);\n  /* Native Javascript for Bootstrap 4 | Modal\n  -------------------------------------------*/\n  // MODAL DEFINITION\n  // ===============\n\n  var Modal = function Modal(element, options) {\n    // element can be the modal/triggering button\n    // the modal (both JavaScript / DATA API init) / triggering button element (DATA API)\n    element = queryElement(element); // strings\n\n    var component = 'modal',\n        staticString = 'static',\n        modalTrigger = 'modalTrigger',\n        paddingRight = 'paddingRight',\n        modalBackdropString = 'modal-backdrop',\n        // determine modal, triggering element\n    btnCheck = element[getAttribute](dataTarget) || element[getAttribute]('href'),\n        checkModal = queryElement(btnCheck),\n        modal = hasClass(element, component) ? element : checkModal;\n\n    if (hasClass(element, component)) {\n      element = null;\n    } // modal is now independent of it's triggering element\n\n\n    if (!modal) {\n      return;\n    } // invalidate\n    // set options\n\n\n    options = options || {};\n    this[keyboard] = options[keyboard] === false || modal[getAttribute](dataKeyboard) === 'false' ? false : true;\n    this[backdrop] = options[backdrop] === staticString || modal[getAttribute](databackdrop) === staticString ? staticString : true;\n    this[backdrop] = options[backdrop] === false || modal[getAttribute](databackdrop) === 'false' ? false : this[backdrop];\n    this[content] = options[content]; // JavaScript only\n    // bind, constants, event targets and other vars\n\n    var self = this,\n        relatedTarget = null,\n        bodyIsOverflowing,\n        scrollBarWidth,\n        overlay,\n        overlayDelay,\n        // also find fixed-top / fixed-bottom items\n    fixedItems = getElementsByClassName(HTML, fixedTop).concat(getElementsByClassName(HTML, fixedBottom)),\n        // private methods\n    getWindowWidth = function getWindowWidth() {\n      var htmlRect = HTML[getBoundingClientRect]();\n      return globalObject[innerWidth] || htmlRect[right] - Math.abs(htmlRect[left]);\n    },\n        setScrollbar = function setScrollbar() {\n      var bodyStyle = globalObject[getComputedStyle](DOC[body]),\n          bodyPad = parseInt(bodyStyle[paddingRight], 10),\n          itemPad;\n\n      if (bodyIsOverflowing) {\n        DOC[body][style][paddingRight] = bodyPad + scrollBarWidth + 'px';\n        modal[style][paddingRight] = scrollBarWidth + 'px';\n\n        if (fixedItems[length]) {\n          for (var i = 0; i < fixedItems[length]; i++) {\n            itemPad = globalObject[getComputedStyle](fixedItems[i])[paddingRight];\n            fixedItems[i][style][paddingRight] = parseInt(itemPad) + scrollBarWidth + 'px';\n          }\n        }\n      }\n    },\n        resetScrollbar = function resetScrollbar() {\n      DOC[body][style][paddingRight] = '';\n      modal[style][paddingRight] = '';\n\n      if (fixedItems[length]) {\n        for (var i = 0; i < fixedItems[length]; i++) {\n          fixedItems[i][style][paddingRight] = '';\n        }\n      }\n    },\n        measureScrollbar = function measureScrollbar() {\n      // thx walsh\n      var scrollDiv = DOC[createElement]('div'),\n          widthValue;\n      scrollDiv.className = component + '-scrollbar-measure'; // this is here to stay\n\n      DOC[body][appendChild](scrollDiv);\n      widthValue = scrollDiv[offsetWidth] - scrollDiv[clientWidth];\n      DOC[body].removeChild(scrollDiv);\n      return widthValue;\n    },\n        checkScrollbar = function checkScrollbar() {\n      bodyIsOverflowing = DOC[body][clientWidth] < getWindowWidth();\n      scrollBarWidth = measureScrollbar();\n    },\n        createOverlay = function createOverlay() {\n      modalOverlay = 1;\n      var newOverlay = DOC[createElement]('div');\n      overlay = queryElement('.' + modalBackdropString);\n\n      if (overlay === null) {\n        newOverlay[setAttribute]('class', modalBackdropString + ' fade');\n        overlay = newOverlay;\n        DOC[body][appendChild](overlay);\n      }\n    },\n        removeOverlay = function removeOverlay() {\n      overlay = queryElement('.' + modalBackdropString);\n\n      if (overlay && overlay !== null && _typeof(overlay) === 'object') {\n        modalOverlay = 0;\n        DOC[body].removeChild(overlay);\n        overlay = null;\n      }\n\n      bootstrapCustomEvent.call(modal, hiddenEvent, component);\n    },\n        keydownHandlerToggle = function keydownHandlerToggle() {\n      if (hasClass(modal, showClass)) {\n        on(DOC, keydownEvent, keyHandler);\n      } else {\n        off(DOC, keydownEvent, keyHandler);\n      }\n    },\n        resizeHandlerToggle = function resizeHandlerToggle() {\n      if (hasClass(modal, showClass)) {\n        on(globalObject, resizeEvent, self.update);\n      } else {\n        off(globalObject, resizeEvent, self.update);\n      }\n    },\n        dismissHandlerToggle = function dismissHandlerToggle() {\n      if (hasClass(modal, showClass)) {\n        on(modal, clickEvent, dismissHandler);\n      } else {\n        off(modal, clickEvent, dismissHandler);\n      }\n    },\n        // triggers\n    triggerShow = function triggerShow() {\n      resizeHandlerToggle();\n      dismissHandlerToggle();\n      keydownHandlerToggle();\n      setFocus(modal);\n      bootstrapCustomEvent.call(modal, shownEvent, component, relatedTarget);\n    },\n        triggerHide = function triggerHide() {\n      modal[style].display = '';\n      element && setFocus(element);\n\n      (function () {\n        if (!getElementsByClassName(DOC, component + ' ' + showClass)[0]) {\n          resetScrollbar();\n          removeClass(DOC[body], component + '-open');\n          overlay && hasClass(overlay, 'fade') ? (removeClass(overlay, showClass), emulateTransitionEnd(overlay, removeOverlay)) : removeOverlay();\n          resizeHandlerToggle();\n          dismissHandlerToggle();\n          keydownHandlerToggle();\n        }\n      })();\n    },\n        // handlers\n    clickHandler = function clickHandler(e) {\n      var clickTarget = e[target];\n      clickTarget = clickTarget[hasAttribute](dataTarget) || clickTarget[hasAttribute]('href') ? clickTarget : clickTarget[parentNode];\n\n      if (clickTarget === element && !hasClass(modal, showClass)) {\n        modal[modalTrigger] = element;\n        relatedTarget = element;\n        self.show();\n        e[preventDefault]();\n      }\n    },\n        keyHandler = function keyHandler(e) {\n      if (self[keyboard] && e.which == 27 && hasClass(modal, showClass)) {\n        self.hide();\n      }\n    },\n        dismissHandler = function dismissHandler(e) {\n      var clickTarget = e[target];\n\n      if (hasClass(modal, showClass) && (clickTarget[parentNode][getAttribute](dataDismiss) === component || clickTarget[getAttribute](dataDismiss) === component || clickTarget === modal && self[backdrop] !== staticString)) {\n        self.hide();\n        relatedTarget = null;\n        e[preventDefault]();\n      }\n    }; // public methods\n\n\n    this.toggle = function () {\n      if (hasClass(modal, showClass)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n\n    this.show = function () {\n      bootstrapCustomEvent.call(modal, showEvent, component, relatedTarget); // we elegantly hide any opened modal\n\n      var currentOpen = getElementsByClassName(DOC, component + ' ' + showClass)[0];\n\n      if (currentOpen && currentOpen !== modal) {\n        modalTrigger in currentOpen && currentOpen[modalTrigger][stringModal].hide();\n        stringModal in currentOpen && currentOpen[stringModal].hide();\n      }\n\n      if (this[backdrop]) {\n        !modalOverlay && createOverlay();\n      }\n\n      if (overlay && modalOverlay && !hasClass(overlay, showClass)) {\n        overlay[offsetWidth]; // force reflow to enable trasition\n\n        overlayDelay = getTransitionDurationFromElement(overlay);\n        addClass(overlay, showClass);\n      }\n\n      setTimeout(function () {\n        modal[style].display = 'block';\n        checkScrollbar();\n        setScrollbar();\n        addClass(DOC[body], component + '-open');\n        addClass(modal, showClass);\n        modal[setAttribute](ariaHidden, false);\n        hasClass(modal, 'fade') ? emulateTransitionEnd(modal, triggerShow) : triggerShow();\n      }, supportTransitions && overlay ? overlayDelay : 0);\n    };\n\n    this.hide = function () {\n      bootstrapCustomEvent.call(modal, hideEvent, component);\n      overlay = queryElement('.' + modalBackdropString);\n      overlayDelay = overlay && getTransitionDurationFromElement(overlay);\n      removeClass(modal, showClass);\n      modal[setAttribute](ariaHidden, true);\n      setTimeout(function () {\n        hasClass(modal, 'fade') ? emulateTransitionEnd(modal, triggerHide) : triggerHide();\n      }, supportTransitions && overlay ? overlayDelay : 0);\n    };\n\n    this.setContent = function (content) {\n      queryElement('.' + component + '-content', modal)[innerHTML] = content;\n    };\n\n    this.update = function () {\n      if (hasClass(modal, showClass)) {\n        checkScrollbar();\n        setScrollbar();\n      }\n    }; // init\n    // prevent adding event handlers over and over\n    // modal is independent of a triggering element\n\n\n    if (!!element && !(stringModal in element)) {\n      on(element, clickEvent, clickHandler);\n    }\n\n    if (!!self[content]) {\n      self.setContent(self[content]);\n    }\n\n    if (element) {\n      element[stringModal] = self;\n      modal[modalTrigger] = element;\n    } else {\n      modal[stringModal] = self;\n    }\n  }; // DATA API\n\n\n  supports[push]([stringModal, Modal, '[' + dataToggle + '=\"modal\"]']);\n  return {\n    Carousel: Carousel,\n    Modal: Modal\n  };\n});\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],12:[function(require,module,exports){\n\"use strict\";\n\nfunction start() {\n  require('./website/controls/lazy-load');\n\n  require('./website/controls/smooth-scroll');\n\n  require('./website/base/partials/javascripts/in-viewport');\n\n  require('./website/controls/audio-player');\n\n  require('./website/controls/carousel-zoom');\n\n  require('./website/controls/carousel-fade');\n\n  require('./website/controls/hover-diagram');\n\n  require('./website/controls/modal-dialog');\n\n  require('./website/controls/pell-editor');\n\n  require('./website/controls/parallax');\n}\n\nwindow.runScripts(start);\n\n},{\"./website/base/partials/javascripts/in-viewport\":13,\"./website/controls/audio-player\":17,\"./website/controls/carousel-fade\":18,\"./website/controls/carousel-zoom\":19,\"./website/controls/hover-diagram\":20,\"./website/controls/lazy-load\":21,\"./website/controls/modal-dialog\":22,\"./website/controls/parallax\":23,\"./website/controls/pell-editor\":24,\"./website/controls/smooth-scroll\":25}],13:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar defaults = {\n  visibilityClass: 'in-viewport',\n  enterEventName: 'enter',\n  leaveEventName: 'leave',\n  observerConfig: {\n    root: null,\n    rootMargin: '250px',\n    threshold: 0\n  }\n};\n\nvar InViewport =\n/*#__PURE__*/\nfunction () {\n  function InViewport(elements) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, InViewport);\n\n    // Plugin options\n    this.options = _objectSpread({}, defaults, options); // Track section visibility, without penetrating DOM\n\n    this.visible = new Map(); // Tracked elements\n\n    this.elements = elements; // Intersection Observer instance\n\n    this.observer = new IntersectionObserver(this.handler.bind(this), this.options.observerConfig); // Observe elements\n\n    this.elements.forEach(function (element) {\n      return _this.observe(element);\n    });\n  }\n\n  _createClass(InViewport, [{\n    key: \"observe\",\n    value: function observe(element) {\n      this.observer.observe(element);\n    }\n  }, {\n    key: \"handler\",\n    value: function handler(entries) {\n      var _this2 = this;\n\n      entries.forEach(function (entry) {\n        var intersect = entry.isIntersecting;\n\n        var visible = _this2.visible.get(entry.target); // Element enters viewport\n\n\n        if (intersect && !visible) {\n          _this2.visible.set(entry.target, true);\n\n          entry.target.classList.toggle(_this2.options.visibilityClass, true);\n          entry.target.dispatchEvent(new CustomEvent(_this2.options.enterEventName));\n        } // Element leaves viewport\n\n\n        if (!intersect && visible) {\n          _this2.visible.set(entry.target, false);\n\n          entry.target.classList.toggle(_this2.options.visibilityClass, false);\n          entry.target.dispatchEvent(new CustomEvent(_this2.options.leaveEventName));\n        }\n      });\n    }\n  }]);\n\n  return InViewport;\n}();\n\nexports.default = InViewport;\nnew InViewport(document.querySelectorAll('section'));\n\n},{}],14:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar defaults = {\n  debounce: 50,\n  resizeEventName: 'mode-resize',\n  passive: true,\n  attach: true\n};\nvar modes = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n\nvar ModeResize =\n/*#__PURE__*/\nfunction () {\n  function ModeResize() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ModeResize);\n\n    this.options = _objectSpread({}, defaults, options);\n    this.resizeHandler = this.handleWindowResize.bind(this);\n    if (this.options.attach) this.attach();\n  }\n\n  _createClass(ModeResize, [{\n    key: \"attach\",\n    value: function attach() {\n      window.addEventListener('resize', this.resizeHandler, this.options.passive ? {\n        passive: true\n      } : false);\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      window.removeEventListener('resize', this.resizeHandler);\n    }\n  }, {\n    key: \"handleWindowResize\",\n    value: function handleWindowResize() {\n      var _this = this;\n\n      var handleTimeout = function handleTimeout() {\n        var mode = _this.getWindowWidthMode();\n\n        if (mode === 'xs' || mode !== _this.previousMode) {\n          _this.previousMode = mode;\n\n          _this.triggerResizeMode(mode);\n        }\n      };\n\n      clearTimeout(this.timeout);\n      this.timeout = setTimeout(handleTimeout, this.options.debounce);\n    }\n  }, {\n    key: \"getWindowWidthMode\",\n    value: function getWindowWidthMode() {\n      var result,\n          size = window.innerWidth;\n\n      for (var mode in modes) {\n        if (size >= modes[mode]) result = mode;else break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"triggerResizeMode\",\n    value: function triggerResizeMode(mode) {\n      window.dispatchEvent(new CustomEvent(this.options.resizeEventName, {\n        detail: mode\n      }));\n    }\n  }]);\n\n  return ModeResize;\n}();\n\nexports.default = ModeResize;\n\n},{}],15:[function(require,module,exports){\n'use strict'; // Taken from https://fdossena.com/?p=html5cool/radprog/i.frag\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar RadarProgress =\n/*#__PURE__*/\nfunction () {\n  function RadarProgress(container, options) {\n    var _this = this;\n\n    _classCallCheck(this, RadarProgress);\n\n    this.prevW = 0;\n    this.prevH = 0;\n    this.prevP = 0;\n    this.pause = true; // Default settings\n\n    this.options = {\n      colorBg: '#404040',\n      colorFg: '#007FFF',\n      round: false,\n      thick: 2,\n      progress: 0,\n      animate: true,\n      animationSpeed: 1\n    };\n\n    if (options) {\n      Object.keys(options).forEach(function (key) {\n        _this.options[key] = options[key];\n      });\n    }\n\n    this.options.initialProgress = options.animate ? 0 : this.options.progress;\n    this.updateHandler = this.update.bind(this);\n    this.init(container);\n    this.update();\n  }\n\n  _createClass(RadarProgress, [{\n    key: \"init\",\n    value: function init(container) {\n      var holder = document.createElement('div');\n      holder.style.width = '10em';\n      holder.style.height = '10em';\n      holder.style.position = 'relative';\n      var canvas = document.createElement('canvas');\n      canvas.style.position = 'absolute';\n      canvas.style.top = '0';\n      canvas.style.left = '0';\n      canvas.style.width = '100%';\n      canvas.style.height = '100%';\n      holder.appendChild(canvas);\n      container.appendChild(holder);\n      this.canvas = canvas;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var canvas = this.canvas;\n      var dp = window.devicePixelRatio || 1;\n      canvas.width = canvas.clientWidth * dp;\n      canvas.height = canvas.clientHeight * dp; // Save CPU cycles\n\n      if (this.pause === false && !(this.prevP - this.options.progress < 1 && this.prevW === canvas.width && this.prevH === canvas.height)) {\n        this.animate();\n      } // Countdown\n      else if (this.pause !== true && this.pause !== false && this.pause > 0) {\n          this.animate();\n          this.pause--;\n          if (this.pause === 0) this.pause = true;\n        }\n\n      if (this.pause === false) window.requestAnimationFrame(this.updateHandler);\n    }\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      // console.log('animate', this.options.animate);\n      var canvas = this.canvas;\n      var bw = canvas.clientWidth / 100.0,\n          dp = window.devicePixelRatio || 1,\n          centerX = canvas.width / 2,\n          centerY = canvas.height / 2,\n          radius = canvas.height / 2 - this.options.thick * bw * dp / 2;\n\n      if (this.options.animate) {\n        var aniF = Math.pow(0.93, this.options.animationSpeed);\n        this.options.initialProgress = this.options.initialProgress * aniF + this.options.progress * (1 - aniF);\n      } else {\n        this.options.initialProgress = this.options.progress;\n      }\n\n      var context = canvas.getContext('2d');\n      if (this.options.round) context.lineCap = 'round';\n      context.lineWidth = this.options.thick * bw * dp;\n      context.beginPath();\n      context.strokeStyle = this.options.colorBg;\n      context.arc(centerX, centerY, radius, -Math.PI / 2, 2 * Math.PI);\n      context.stroke();\n      context.beginPath();\n      context.strokeStyle = this.options.colorFg;\n      context.arc(centerX, centerY, radius, -1 * Math.PI / 2, this.options.initialProgress * (2 * Math.PI) - Math.PI / 2);\n      context.stroke();\n      this.prevW = context.width;\n      this.prevH = context.height;\n      this.prevP = this.options.initialProgress;\n    }\n  }, {\n    key: \"attach\",\n    value: function attach() {\n      this.pause = false;\n      this.update();\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.pause = 5;\n    }\n  }, {\n    key: \"setProgress\",\n    value: function setProgress(p, reset) {\n      this.options.progress = p < 0 ? 0 : p > 1 ? 1 : p;\n      if (reset) this.options.initialProgress = this.options.progress;\n    }\n  }]);\n\n  return RadarProgress;\n}();\n\nexports.default = RadarProgress;\n\n},{}],16:[function(require,module,exports){\n'use strict'; // Taken from https://github.com/dixonandmoe/rellax\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar RellaxParallax =\n/*#__PURE__*/\nfunction () {\n  function RellaxParallax(el, options) {\n    var _this = this;\n\n    _classCallCheck(this, RellaxParallax);\n\n    this.loopId = null;\n    this.posY = 0;\n    this.posX = 0;\n    this.screenY = 0;\n    this.screenX = 0;\n    this.blocks = [];\n    this.pause = true; // Default settings\n\n    this.options = {\n      speed: -2,\n      wrapper: null,\n      round: true,\n      vertical: true,\n      horizontal: false,\n      scroll: false,\n      callback: function callback() {}\n    }; // User defined options (might have more in the future)\n\n    if (options) {\n      Object.keys(options).forEach(function (key) {\n        _this.options[key] = options[key];\n      });\n    } // By default, rellax class\n\n\n    if (!el) {\n      el = '.rellax';\n    } // check if el is a className or a node\n\n\n    var elements = typeof el === 'string' ? document.querySelectorAll(el) : el; // Now query selector\n\n    if (elements.length > 0) {\n      this.elems = elements;\n    } // The elements don't exist\n    else {\n        throw new Error('The elements you\\'re trying to select don\\'t exist.');\n      } // Has a wrapper and it exists\n\n\n    if (this.options.wrapper) {\n      if (!this.options.wrapper.nodeType) {\n        var wrapper = document.querySelector(this.options.wrapper);\n\n        if (wrapper) {\n          this.options.wrapper = wrapper;\n        } else {\n          throw new Error('The wrapper you\\'re trying to use don\\'t exist.');\n        }\n      }\n    } // this.initHandler = this.init.bind(this);\n\n\n    this.updateHandler = this.update.bind(this); // Init\n\n    this.init(); // Start the loop\n    // this.update();\n  } // Get and cache initial position of all elements\n\n\n  _createClass(RellaxParallax, [{\n    key: \"cacheBlocks\",\n    value: function cacheBlocks() {\n      for (var i = 0; i < this.elems.length; i++) {\n        var block = this.createBlock(this.elems[i]);\n        this.blocks.push(block);\n      }\n    } // Let's kick this script off\n    // Build array for cached element values\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      if (this.options.wrapper) {\n        // Scroll top position\n        var scrollPosY = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop; // Remember wrapper offset top\n\n        this.wrapperOffsetTop = this.options.wrapper.getBoundingClientRect().top + scrollPosY; // Remember wrapper height\n\n        this.wrapperOffsetHeight = this.options.wrapper.offsetHeight;\n      }\n\n      for (var i = 0; i < this.blocks.length; i++) {\n        this.elems[i].style.cssText = this.blocks[i].style;\n      }\n\n      this.blocks = [];\n      this.screenY = window.innerHeight;\n      this.screenX = window.innerWidth;\n      this.setPosition();\n      this.cacheBlocks(); // Required to make rellax shapes appear without movement on page reload\n\n      this.animate();\n    } // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n\n  }, {\n    key: \"createBlock\",\n    value: function createBlock(el) {\n      var dataMin = el.getAttribute('data-rellax-min');\n      var dataMax = el.getAttribute('data-rellax-max');\n      var dataSpeed = el.getAttribute('data-rellax-speed');\n      var dataZindex = el.getAttribute('data-rellax-zindex') || 0;\n      var posY = 0;\n      var posX = 0;\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n      var blockLeft = posX + el.getBoundingClientRect().left;\n      var blockWidth = el.clientWidth || el.offsetWidth || el.scrollWidth; // Apparently parallax equation everyone uses\n\n      var percentageY = (posY - blockTop + this.screenY) / (blockHeight + this.screenY);\n      var percentageX = (posX - blockLeft + this.screenX) / (blockWidth + this.screenX); // Optional individual block speed as data attr, otherwise global speed\n\n      var speed = dataSpeed ? dataSpeed : this.options.speed;\n      var bases = this.updatePosition(percentageX, percentageY, speed); // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n\n      var style = el.style.cssText;\n      var transform = ''; // Check if there's an inline styled transform\n\n      if (style.indexOf('transform') >= 0) {\n        // Get the index of the transform\n        var index = style.indexOf('transform'); // Trim the style to the transform point and get the following semi-colon index\n\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';'); // Remove \"transform\" string and save the attribute\n\n        if (delimiter) {\n          transform = ' ' + trimmedStyle.slice(11, delimiter).replace(/\\s/g, '');\n        } else {\n          transform = ' ' + trimmedStyle.slice(11).replace(/\\s/g, '');\n        }\n      }\n\n      return {\n        baseX: bases.x,\n        baseY: bases.y,\n        top: blockTop,\n        left: blockLeft,\n        height: blockHeight,\n        width: blockWidth,\n        speed: speed,\n        style: style,\n        transform: transform,\n        zindex: dataZindex,\n        min: dataMin,\n        max: dataMax\n      };\n    } // set scroll position (posY, posX)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(scrollY) {\n      var oldY = this.posY;\n      var oldX = this.posX;\n      var scrollPosY = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop;\n      this.posY = (scrollY || scrollPosY) + this.screenY / 2 - this.wrapperOffsetTop - this.wrapperOffsetHeight / 2;\n      this.posX = this.options.wrapper ? this.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset;\n\n      if (oldY !== this.posY && this.options.vertical) {\n        // scroll changed, return true\n        return true;\n      }\n\n      if (oldX !== this.posX && this.options.horizontal) {\n        // scroll changed, return true\n        return true;\n      } // scroll did not change\n\n\n      return false;\n    } // Ahh a pure function, gets new transform value\n    // based on scrollPosition and speed\n    // Allow for decimal pixel values\n\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition(percentageX, percentageY, speed) {\n      var result = {};\n      var valueX = speed * (100 * (1 - percentageX));\n      var valueY = speed * (100 * (1 - percentageY));\n      result.x = this.options.round ? Math.round(valueX * 1.00) : Math.round(valueX * 100) / 100;\n      result.y = this.options.round ? Math.round(valueY * 1.00) : Math.round(valueY * 100) / 100;\n      return result;\n    } // Loop\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.pause === false && this.setPosition()) {\n        this.animate();\n      }\n\n      if (this.pause === false && !this.options.scroll) this.loopId = window.requestAnimationFrame(this.updateHandler);\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh(scrollY) {\n      this.setPosition(scrollY);\n      this.animate();\n    } // Transform3d on parallax element\n\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      var positions;\n\n      for (var i = 0; i < this.elems.length; i++) {\n        var percentageY = (this.posY - this.blocks[i].top + this.screenY) / (this.blocks[i].height + this.screenY);\n        var percentageX = (this.posX - this.blocks[i].left + this.screenX) / (this.blocks[i].width + this.screenX); // Subtracting initialize value, so element stays in same spot as HTML\n\n        positions = this.updatePosition(percentageX, percentageY, this.blocks[i].speed); // - blocks[i].baseX;\n\n        var positionY = positions.y - this.blocks[i].baseY;\n        var positionX = positions.x - this.blocks[i].baseX; // Check if a min limit is defined\n\n        if (this.blocks[i].min !== null) {\n          if (this.options.vertical && !this.options.horizontal) {\n            positionY = positionY <= this.blocks[i].min ? this.blocks[i].min : positionY;\n          }\n\n          if (this.options.horizontal && !this.options.vertical) {\n            positionX = positionX <= this.blocks[i].min ? this.blocks[i].min : positionX;\n          }\n        } // Check if a max limit is defined\n\n\n        if (this.blocks[i].max !== null) {\n          if (this.options.vertical && !this.options.horizontal) {\n            positionY = positionY >= this.blocks[i].max ? this.blocks[i].max : positionY;\n          }\n\n          if (this.options.horizontal && !this.options.vertical) {\n            positionX = positionX >= this.blocks[i].max ? this.blocks[i].max : positionX;\n          }\n        }\n\n        var zindex = this.blocks[i].zindex; // Move that element\n        // (Set the new translation and append initial inline transforms.)\n\n        this.elems[i].style['transform'] = 'translate3d(' + (this.options.horizontal ? positionX : '0') + 'px,' + (this.options.vertical ? positionY : '0') + 'px,' + zindex + 'px) ' + this.blocks[i].transform;\n      }\n\n      this.options.callback(positions);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      for (var i = 0; i < this.blocks.length; i++) {\n        this.elems[i].style.cssText = this.blocks[i].style;\n      }\n    }\n  }, {\n    key: \"attach\",\n    value: function attach() {\n      if (this.pause) {\n        if (this.options.scroll) {\n          document.addEventListener('scroll', this.updateHandler);\n        }\n\n        this.update();\n        this.pause = false;\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (!this.pause) {\n        if (this.options.scroll) {\n          document.removeEventListener('scroll', this.updateHandler);\n        } else {\n          window.cancelAnimationFrame(this.loopId);\n          this.loopId = null;\n        }\n\n        this.pause = true;\n      }\n    }\n  }]);\n\n  return RellaxParallax;\n}();\n\nexports.default = RellaxParallax;\n\n},{}],17:[function(require,module,exports){\n\"use strict\";\n\nvar _radarProgress = _interopRequireDefault(require(\"../base/partials/javascripts/radar-progress\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 'use strict';\nvar baseSelector = '[data-plugin=audio-player]';\nvar baseNode = document.querySelector(baseSelector);\n\nif (baseNode) {\n  var html = '<span class=\"time-label\">loading...</span>' + '<span class=\"play-status\"></span>' + '<button class=\"button-stop\" type=\"button\" aria-label=\"Stop audio\"></button>' + '<button class=\"button-play\" type=\"button\" aria-label=\"Play audio\">' + '<span class=\"radial-border\"></span>' + '<span class=\"radial-progress\"></span>' + '<i class=\"icon icon-player-play\"></i>' + '<i class=\"icon icon-player-pause\"></i>' + '</button>';\n  baseNode.innerHTML = html;\n  var playerNode = baseNode;\n  var sectionNode = baseNode.closest('section');\n  var progressNode = playerNode.querySelector('.radial-progress');\n  var timeLabelNode = playerNode.querySelector('.time-label');\n  var playButtonNode = playerNode.querySelector('.button-play');\n  var stopButtonNode = playerNode.querySelector('.button-stop');\n  var progress = new _radarProgress.default(progressNode, {\n    progress: 1 / 360,\n    animate: true,\n    colorBg: 'rgba(255, 255, 255, 0.25)',\n    colorFg: 'rgba(255, 255, 255, 1.00)',\n    round: true,\n    thick: 4\n  });\n\n  var startPlaying = function startPlaying() {\n    progress.attach();\n    playerNode.classList.toggle('playing', true);\n    playerNode.classList.toggle('paused', false);\n  };\n\n  var stopPlaying = function stopPlaying() {\n    progress.setProgress(1 / 360, true);\n    progress.detach();\n    playerNode.classList.toggle('playing', false);\n    playerNode.classList.toggle('paused', false);\n  };\n\n  var pausePlaying = function pausePlaying() {\n    progress.detach();\n    playerNode.classList.toggle('playing', false);\n    playerNode.classList.toggle('paused', true);\n  };\n\n  var player = document.createElement('audio');\n  player.src = playerNode.getAttribute('href');\n  playerNode.appendChild(player);\n  player.addEventListener('pause', function () {\n    if (player.currentTime > 0) {\n      pausePlaying();\n    } else {\n      stopPlaying();\n    }\n  });\n  player.addEventListener('playing', function () {\n    startPlaying();\n  }); // player.addEventListener('ended', () => {\n  //   console.log('Audio ended', player.currentTime);\n  // });\n  // let screen = new OnScreen({tolerance: 0, debounce: 5});\n  // screen.on('enter', baseSelector, function() {toggleVisible(true);});\n  // screen.on('leave', baseSelector, function() {toggleVisible(false);});\n  // When player is outside the viewport, we should not update\n  // playing time label and radial progress. It causes parallax\n  // flickering. Instead, we remember these values in variables\n  // and update player controls when it scrolls back into view.\n\n  var visible = null;\n  var labelProgress = null;\n  var roundProgress = null;\n\n  var toggleVisible = function toggleVisible(value) {\n    if (!player.paused) {\n      if (value) {\n        // If we are reattaching player in a playing state,\n        // we should update it with the most recent values,\n        // and suppress progress animation.\n        if (visible === false) {\n          progress.setProgress(roundProgress, true);\n          timeLabelNode.innerText = labelProgress;\n        }\n\n        progress.attach();\n      } else {\n        progress.detach();\n      }\n    }\n\n    visible = value;\n  };\n\n  sectionNode.addEventListener('enter', toggleVisible.bind(void 0, true));\n  sectionNode.addEventListener('leave', toggleVisible.bind(void 0, false));\n\n  var formatTime = function formatTime(length) {\n    var minutes = Math.floor(length / 60),\n        seconds = Math.floor(length - minutes * 60),\n        minutesPre = minutes < 10 ? '0' + minutes : minutes,\n        secondsPre = seconds < 10 ? '0' + seconds : seconds;\n    return minutesPre + ':' + secondsPre;\n  };\n\n  player.addEventListener('timeupdate', function () {\n    labelProgress = formatTime(player.currentTime) + ' / ' + formatTime(player.duration);\n    roundProgress = Math.max(1 / 360, player.currentTime / player.duration);\n\n    if (visible) {\n      progress.setProgress(roundProgress);\n      timeLabelNode.innerText = labelProgress;\n    }\n  });\n  player.addEventListener('ended', function () {\n    togglePlaying(true);\n  });\n  playerNode.addEventListener('click', function (e) {\n    e.preventDefault();\n  });\n  playButtonNode.addEventListener('click', function () {\n    togglePlaying();\n  });\n  stopButtonNode.addEventListener('click', function () {\n    togglePlaying(true);\n  });\n  document.addEventListener('keydown', function (e) {\n    if (!window.modalIsOpen && e.code === 'Escape') {\n      togglePlaying(true);\n    }\n  });\n\n  var togglePlaying = function togglePlaying(stop) {\n    if (stop) {\n      if (player.paused) {\n        stopPlaying();\n      } else {\n        player.pause();\n      }\n\n      player.currentTime = 0.0;\n    } else {\n      if (player.paused === false) {\n        player.pause();\n      } else {\n        player.play();\n      }\n    }\n  };\n}\n\n},{\"../base/partials/javascripts/radar-progress\":15}],18:[function(require,module,exports){\n\"use strict\";\n\nvar _bootstrap = _interopRequireDefault(require(\"../../imports/_bootstrap\"));\n\nvar _src = _interopRequireDefault(require(\"xwiper/src\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar baseSelector = '[data-plugin=carousel-fade]';\nvar baseNode = document.querySelector(baseSelector);\n\nif (baseNode) {\n  // Carousel instance\n  var carousel = window.carousel = new _bootstrap.default.Carousel(baseNode, {\n    interval: 5000\n  }); // Attach swipe detection\n\n  var xwiper = new _src.default(baseNode, {\n    threshold: 100,\n    passive: true\n  }); // Swipe gesture handlers\n\n  xwiper.onSwipeLeft(function () {\n    carousel.slideTo(carousel.getActiveIndex() + 1);\n  });\n  xwiper.onSwipeRight(function () {\n    carousel.slideTo(carousel.getActiveIndex() - 1);\n  });\n}\n\n},{\"../../imports/_bootstrap\":11,\"xwiper/src\":10}],19:[function(require,module,exports){\n\"use strict\";\n\nvar _bootstrap = _interopRequireDefault(require(\"../../imports/_bootstrap\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar baseSelector = '[data-plugin=carousel-zoom]';\nvar baseNode = document.querySelector(baseSelector);\n\nif (baseNode) {\n  var sectionNode = baseNode.closest('section'); // Auto-slide interval\n\n  var autoSlideInterval = 7500; // Carousel node\n\n  var carouselNode = baseNode; // Carousel inner node\n\n  var carouselInnerNode = carouselNode.querySelector('.carousel-inner'); // Slide nodes\n\n  var slideNodes = carouselInnerNode.querySelectorAll('.carousel-item'); // Block visibility\n\n  var visible = false; // Carousel instance\n\n  var carousel = new _bootstrap.default.Carousel(carouselNode, {\n    interval: false\n  }); // Screen tracker\n  // let screen = new OnScreen({tolerance: 0, debounce: 5});\n\n  sectionNode.addEventListener('enter', function () {\n    if (!visible) {\n      visible = true;\n      window.toggleQuotesCarousel(true);\n    }\n  });\n  sectionNode.addEventListener('leave', function () {\n    if (visible) {\n      visible = false;\n      window.toggleQuotesCarousel(false);\n    }\n  }); // Updates carousel height to prevent slide jumps\n  //\n\n  var updateSlideHeights = function updateSlideHeights() {\n    var maxHeight = 0; // Calculate slide heights\n\n    slideNodes.forEach(function (slideNode) {\n      // Is this slide active?\n      var isActive = slideNode.classList.contains('active'); // Recalculate slide height\n\n      slideNode.classList.toggle('active', true);\n      maxHeight = Math.max(maxHeight, slideNode.clientHeight); // slideNode.dataset.height = slideNode.clientHeight;\n\n      slideNode.classList.toggle('active', isActive);\n    });\n    carouselInnerNode.style.height = maxHeight + 'px';\n  }; // let resizeTimer, handleWindowResize = () => {\n  //\n  //   clearTimeout(resizeTimer);\n  //\n  //   resizeTimer = setTimeout(function() {\n  //     updateSlideHeights();\n  //   }, 250);\n  //\n  // };\n\n\n  updateSlideHeights();\n  window.addEventListener('mode-resize', updateSlideHeights); // Auto-slide function\n\n  var timer,\n      timerFunction = function timerFunction() {\n    carousel.slideTo(carousel.getActiveIndex() + 1);\n  }; // Slides carousel to specified slide\n\n\n  window.slideToReview = function (id) {\n    carousel.slideTo(id);\n  }; // Pauses carousel\n\n\n  window.toggleQuotesCarousel = function (value) {\n    clearInterval(timer);\n\n    if (value) {\n      carouselNode.style.willChange = 'opacity, transform';\n      timer = setInterval(timerFunction, autoSlideInterval);\n    } else {\n      timer = null;\n      carouselNode.style.willChange = '';\n    }\n  };\n}\n\n},{\"../../imports/_bootstrap\":11}],20:[function(require,module,exports){\n\"use strict\";\n\nvar baseSelector = '[data-plugin=hover-diagram]';\nvar baseNode = document.querySelector(baseSelector);\n\nif (baseNode) {\n  var mapping = {\n    'xx': ['b1', 'b2', 'b3', 'b4', 'b5', 't1', 't2', 't3', 't4', 't5'],\n    'b1': ['b1', 't1', 't3', 't4', 't5'],\n    'b2': ['b2', 'b1', 't2', 't3', 't4'],\n    'b3': ['b3', 'b1', 't2', 't3', 't4'],\n    'b4': ['b4', 'b1', 'b3', 't2', 't4'],\n    'b5': ['b5', 'b1', 'b3', 't1', 't2'],\n    't1': ['t1', 'b1', 'b3', 'b5'],\n    't2': ['t2', 'b2', 'b3', 'b4', 'b5'],\n    't3': ['t3', 'b1', 'b3', 'b4'],\n    't4': ['t4', 'b1', 'b3', 'b5'],\n    't5': ['t5', 'b1', 'b3', 'b5']\n  };\n  var timeout = null;\n  var blockNode = baseNode;\n  var cardNodes = Array.prototype.slice.call(blockNode.querySelectorAll('.card'));\n  var tickNodes = Array.prototype.slice.call(blockNode.querySelectorAll('.tick'));\n  var prevHoverId = null;\n  blockNode.addEventListener('mouseover', function (e) {\n    if (!e.srcElement.classList.contains('card')) return;\n    var hoverElement = e.srcElement;\n    var hoverId = hoverElement.dataset.id;\n    clearTimeout(timeout);\n    var cardMapping = mapping[hoverId];\n    var tickMapping = cardMapping.map(function (item) {\n      return 'c' + item[1];\n    });\n    cardNodes.forEach(function (cardNode) {\n      cardNode.classList.toggle('check', cardMapping.includes(cardNode.dataset.id));\n    });\n    tickNodes.forEach(function (tickNode) {\n      tickNode.classList.toggle('check', tickMapping.includes(tickNode.dataset.id));\n    });\n    prevHoverId = hoverId;\n  });\n  blockNode.addEventListener('mouseout', function (e) {\n    if (!e.srcElement.classList.contains('card')) return;\n    timeout = setTimeout(function () {\n      prevHoverId = null;\n      cardNodes.forEach(function (cardNode) {\n        cardNode.classList.toggle('check', true);\n      });\n      tickNodes.forEach(function (tickNode) {\n        tickNode.classList.toggle('check', true);\n      });\n    }, 500);\n  });\n}\n\n},{}],21:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// IMPORTANT: Do not use outside <section>\nvar defaults = {\n  loadedClassName: 'loaded',\n  loadClassName: 'load',\n  passive: true\n};\n\nvar LazyLoad =\n/*#__PURE__*/\nfunction () {\n  function LazyLoad(elements) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LazyLoad);\n\n    this.options = _objectSpread({}, defaults, options);\n    this.elements = elements;\n    this.map = new Map();\n    this.mapSectionsToFlips();\n    this.attachOnEnterEvent();\n  }\n\n  _createClass(LazyLoad, [{\n    key: \"mapSectionsToFlips\",\n    value: function mapSectionsToFlips() {\n      var _this = this;\n\n      this.elements.forEach(function (element) {\n        var sectionNode = element.closest('section');\n        if (!_this.map.has(sectionNode)) _this.map.set(sectionNode, []);\n\n        _this.map.get(sectionNode).push(element);\n      });\n    }\n  }, {\n    key: \"attachOnEnterEvent\",\n    value: function attachOnEnterEvent() {\n      var _this2 = this;\n\n      this.map.forEach(function (elementNodes, sectionNode) {\n        var handler = function handler() {\n          sectionNode.removeEventListener('enter', handler);\n          elementNodes.forEach(function (elementNode) {\n            return _this2.startLoading(elementNode);\n          });\n        };\n\n        sectionNode.addEventListener('enter', handler, _this2.options.passive ? {\n          passive: true\n        } : false);\n      });\n    }\n  }, {\n    key: \"startLoading\",\n    value: function startLoading(elementNode) {\n      var _this3 = this;\n\n      // Lazy-load <picture>\n      if (elementNode.tagName === 'PICTURE') {\n        var imageNode = elementNode.querySelector('img');\n        var flipNodes = elementNode.querySelectorAll('[data-srcset],[data-src]');\n        flipNodes.forEach(function (flipNode) {\n          if (flipNode.dataset['src']) flipNode.setAttribute('src', flipNode.dataset['src']);\n          if (flipNode.dataset['srcset']) flipNode.setAttribute('srcset', flipNode.dataset['srcset']);\n        });\n\n        if (imageNode) {\n          imageNode.addEventListener('load', function () {\n            return elementNode.classList.add(_this3.options.loadedClassName);\n          });\n        }\n      } // Lazy-load background\n      else {\n          elementNode.classList.add(this.options.loadClassName);\n        }\n    }\n  }]);\n\n  return LazyLoad;\n}();\n\nexports.default = LazyLoad;\nnew LazyLoad(document.querySelectorAll('[data-plugin=lazy-load]'));\n\n},{}],22:[function(require,module,exports){\n\"use strict\";\n\nvar _bootstrap = _interopRequireDefault(require(\"../../imports/_bootstrap\"));\n\nvar _modeResize = _interopRequireDefault(require(\"../base/partials/javascripts/mode-resize\"));\n\nvar ScrollLock = _interopRequireWildcard(require(\"body-scroll-lock/lib/bodyScrollLock.es6.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import Xwiper from 'xwiper/src';\nvar baseSelector = '[data-plugin=modal-dialog]';\nvar baseNode = document.querySelector(baseSelector);\n\nif (baseNode) {\n  // Initialize mode-resize event\n  var modeResize = new _modeResize.default();\n\n  var initializeDOM = function initializeDOM(parentNode) {\n    var html = '<div id=\"loader\" class=\"modal fade\">' + '<div class=\"modal-dialog loader\">' + '<div class=\"modal-content\">' + '<div class=\"spinner\" role=\"status\">' + '<span class=\"loading\">Loading...</span>' + '</div>' + '</div>' + '</div>' + '</div>' + '<div id=\"reviews\" class=\"modal fade\">' + '<div class=\"modal-dialog\">' + '<div class=\"modal-content\"></div>' + '</div>' + '</div>' + '<div id=\"projects\" class=\"modal fade\">' + '<div class=\"modal-dialog\">' + '<div class=\"modal-content\"></div>' + '</div>' + '</div>';\n    parentNode.insertAdjacentHTML('beforeend', html);\n    return parentNode;\n  };\n\n  var attachModal = function attachModal(selector, file) {\n    // Remembers the width of the modal\n    // See updateSlideHeights()\n    var lastWidth; // Modal elements\n\n    var modalNode = document.querySelector(selector);\n    var modalContentNode = modalNode.querySelector('.modal-content'); // All these references can only be resolved after setting modal content\n\n    var carouselNode = null;\n    var slideNodes = null;\n    var slideNextButton = null;\n    var slidePrevButton = null;\n    var pageNumber = null;\n    var pageCount = null;\n    var modal = new _bootstrap.default.Modal(modalNode, {});\n    var carousel = null; // let xwiper = null;\n\n    function retrieveAjaxContent(file) {\n      return fetch(file).then(function (response) {\n        return response.text();\n      });\n    }\n\n    function toggleCarouselWillChange(value) {\n      carouselNode.style.willChange = value ? 'opacity, transform' : '';\n    }\n\n    function toggleBodyScroll(value) {\n      if (value) ScrollLock.enableBodyScroll(modalNode);else ScrollLock.disableBodyScroll(modalNode);\n    }\n\n    function toggleModalFastCarousel(value) {\n      carouselNode.classList.toggle('slide', !value);\n      modalNode.classList.toggle('modal-fast-slides', value);\n      modalNode.classList.toggle('modal-fast-height', value);\n    }\n\n    function updateSlideHeights(setHeight) {\n      // Remember initial style\n      var initialDisplayValue = modalNode.style.display; // Temporarily show dialog to make calculations possible\n\n      modalNode.style.display = 'block';\n\n      if (modalContentNode.clientWidth !== 0 && modalContentNode.clientWidth !== lastWidth) {\n        // Remember current width as recalculated one\n        lastWidth = modalContentNode.clientWidth; // Calculate slide heights\n\n        slideNodes.forEach(function (slideNode) {\n          // Is this slide active?\n          var isActive = slideNode.classList.contains('active'); // Recalculate slide height\n\n          slideNode.classList.toggle('active', true);\n          slideNode.dataset.height = slideNode.clientHeight;\n          slideNode.classList.toggle('active', isActive); // Update height to match active slide\n\n          if (isActive && setHeight) {\n            carouselNode.style.height = slideNode.dataset.height + 'px';\n          }\n        });\n      } // Remove temporary show hack\n\n\n      modalNode.style.display = initialDisplayValue;\n    }\n\n    function handleWindowResize() {\n      toggleModalFastCarousel(true);\n      updateSlideHeights(true);\n      toggleModalFastCarousel(false);\n    }\n\n    function handleKeydown(e) {\n      if (e.which === 39) carouselSlideBy(+1);\n      if (e.which === 37) carouselSlideBy(-1);\n    } // Update paginator\n\n\n    function updatePagination(slideNode) {\n      pageNumber.innerText = slideNodes.indexOf(slideNode) + 1;\n      pageCount.innerText = slideNodes.length;\n    } // Update carousel height\n\n\n    function updateSlideHeight(slideNode) {\n      carouselNode.style.height = slideNode.dataset.height + 'px';\n    } // Carousel slide to\n\n\n    function carouselSlideTo(index) {\n      toggleModalFastCarousel(true);\n      carousel.slideTo(index);\n      toggleModalFastCarousel(false);\n    } // Carousel slide by\n\n\n    function carouselSlideBy(shift) {\n      carousel.slideTo(carousel.getActiveIndex() + shift);\n    }\n\n    modalNode.addEventListener('show.bs.modal', function () {\n      // Global flag (used by audio player)\n      window.modalIsOpen = true; // Detach parallax\n\n      window.toggleParallax && window.toggleParallax(false); // Pause quotes carousel\n\n      window.toggleQuotesCarousel && window.toggleQuotesCarousel(false); // Enable will-change\n\n      toggleCarouselWillChange(true); // Update slide heights\n\n      updateSlideHeights(false);\n    });\n    modalNode.addEventListener('shown.bs.modal', function () {\n      toggleBodyScroll(false);\n      window.addEventListener('mode-resize', handleWindowResize);\n      window.addEventListener('keydown', handleKeydown);\n    });\n    modalNode.addEventListener('hide.bs.modal', function () {\n      toggleBodyScroll(true);\n      window.removeEventListener('mode-resize', handleWindowResize);\n      window.removeEventListener('keydown', handleKeydown);\n    });\n    modalNode.addEventListener('hidden.bs.modal', function () {\n      // Reattach parallax\n      window.toggleParallax && window.toggleParallax(true); // Pause quotes carousel\n\n      window.toggleQuotesCarousel && window.toggleQuotesCarousel(true); // Disable will-change\n\n      toggleCarouselWillChange(false); // Global flag (used by audio player)\n\n      window.modalIsOpen = false;\n    });\n    return function (pageIndex) {\n      if (!modalContentNode.children.length) {\n        loaderModal.show();\n        setTimeout(function () {\n          retrieveAjaxContent(file).then(function (content) {\n            // Set DOM content first\n            modal.setContent(content); // Carousel nodes\n\n            carouselNode = modalContentNode.querySelector('.carousel'); // Slide nodes\n\n            slideNodes = Array.prototype.slice.call(carouselNode.querySelectorAll('.carousel-item')); // Navigation nodes\n\n            slideNextButton = modalContentNode.querySelector('.modal-footer .slide-next');\n            slidePrevButton = modalContentNode.querySelector('.modal-footer .slide-prev');\n            pageNumber = modalContentNode.querySelector('.modal-footer .page-number');\n            pageCount = modalContentNode.querySelector('.modal-footer .page-count'); // Carousel instance\n\n            carousel = new _bootstrap.default.Carousel(carouselNode, {\n              interval: false,\n              keyboard: false\n            }); // Initially set content height equal to active slide height\n\n            updateSlideHeight(carouselNode.querySelector('.active'));\n            updatePagination(carouselNode.querySelector('.active')); // Handle slide event\n\n            carouselNode.addEventListener('slide.bs.carousel', function (e) {\n              updateSlideHeight(e.relatedTarget);\n              updatePagination(e.relatedTarget);\n            });\n            slidePrevButton.addEventListener('click', carouselSlideBy.bind(this, -1));\n            slideNextButton.addEventListener('click', carouselSlideBy.bind(this, +1)); // Attach swipe detection\n            // xwiper = new Xwiper(modalContentNode, {threshold: 100, passive: true});\n            // Swipe gesture handlers\n            // xwiper.onSwipeLeft(carouselSlideBy.bind(this, +1));\n            // xwiper.onSwipeRight(carouselSlideBy.bind(this, -1));\n            // Show modal\n            // if (isLoading) {\n\n            modal.show();\n            carouselSlideTo(pageIndex); // }\n          });\n        }, 500);\n      } else {\n        modal.show();\n        carouselSlideTo(pageIndex);\n      }\n    };\n  };\n\n  var blockNode = initializeDOM(document.body);\n  var loaderModalNode = blockNode.querySelector('#loader');\n  var loaderModal = new _bootstrap.default.Modal(loaderModalNode, {}); // let isLoading = null;\n  //\n  // loaderModalNode.addEventListener('show.bs.modal', function() {console.log('isLoading = true'); isLoading = true;});\n  // loaderModalNode.addEventListener('hide.bs.modal', function() {console.log('isLoading = false'); isLoading = false;});\n  // Initializing calls\n  //\n\n  var showReviewsModal = attachModal('#reviews', 'reviews.html');\n  var showProjectsModal = attachModal('#projects', 'projects.html'); // External callbacks\n  //\n\n  window.openReview = function (pageId) {\n    showReviewsModal(pageId - 1);\n  };\n\n  window.openProject = function (pageId) {\n    showProjectsModal(pageId - 1);\n  };\n}\n\n},{\"../../imports/_bootstrap\":11,\"../base/partials/javascripts/mode-resize\":14,\"body-scroll-lock/lib/bodyScrollLock.es6.js\":1}],23:[function(require,module,exports){\n\"use strict\";\n\nvar _rellaxParallax = _interopRequireDefault(require(\"../base/partials/javascripts/rellax-parallax\"));\n\nvar _this = void 0;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar blockSelector = '[data-plugin=rellax-parallax]';\nvar blockNodes = document.querySelectorAll(blockSelector);\n\nif (blockNodes.length) {\n  // let resizeTimer, resizeTimeout = 250;\n  var rellaxString = 'Rellax';\n  var shapeSelector = '.rellax';\n\n  var toggle = function toggle(blockNode, value) {\n    var rellax = blockNode[rellaxString];\n\n    if (rellax) {\n      if (value) {\n        blockNode.classList.toggle('rellax-animate', false);\n        blockNode.classList.toggle('rellax-visible', false);\n        rellax.attach();\n        rellax.update(); // Delay is required to prevent movement animation when rellax shape scrolls in\n\n        window.requestAnimationFrame(function () {\n          blockNode.classList.toggle('rellax-animate', true);\n          blockNode.classList.toggle('rellax-visible', true);\n        });\n      } else {\n        rellax.update();\n        rellax.detach();\n        blockNode.classList.toggle('rellax-visible', false); // blockNode.addEventListener('transitionend', function() {\n        //   blockNode.classList.toggle('rellax-animate', false);\n        // }, {once: true});\n      }\n    }\n  }; // let screen = new OnScreen({tolerance: -250, debounce: 5});\n  // screen.on('enter', blockSelector, function(blockNode) {toggle(blockNode, true);});\n  // screen.on('leave', blockSelector, function(blockNode) {toggle(blockNode, false);});\n  // Attach parallax\n\n\n  blockNodes.forEach(function (blockNode) {\n    var shapes = blockNode.querySelectorAll(shapeSelector);\n    var config = {\n      wrapper: blockNode,\n      round: false,\n      scroll: false\n    };\n\n    if (shapes.length) {\n      blockNode[rellaxString] = new _rellaxParallax.default(shapes, config);\n    }\n  }); // Attach Intersection Observer\n\n  blockNodes.forEach(function (blockNode) {\n    var sectionNode = blockNode.closest('section');\n\n    if (sectionNode) {\n      sectionNode.addEventListener('enter', toggle.bind(_this, blockNode, true));\n      sectionNode.addEventListener('leave', toggle.bind(_this, blockNode, false));\n    }\n  });\n  window.addEventListener('mode-resize', function () {\n    // clearTimeout(resizeTimer);\n    // resizeTimer = setTimeout(window.updateParallax, resizeTimeout);\n    window.updateParallax();\n  });\n\n  window.updateParallax = function () {\n    blockNodes.forEach(function (blockNode) {\n      var rellax = blockNode[rellaxString];\n\n      if (rellax) {\n        rellax.init();\n      }\n    });\n  };\n\n  window.toggleParallax = function (value) {\n    if (value) {\n      // console.log('Toggle parallax: ', value);\n      // screen.attach();\n      blockNodes.forEach(function (blockNode) {\n        var rellax = blockNode[rellaxString];\n\n        if (rellax) {\n          if (rellax.detached) {\n            toggle(blockNode, true);\n            delete rellax.detached;\n          }\n        }\n      });\n    } else {\n      // screen.destroy();\n      blockNodes.forEach(function (blockNode) {\n        var rellax = blockNode[rellaxString];\n\n        if (rellax) {\n          if (rellax.pause) {\n            blockNode.classList.toggle('rellax-animate', false);\n          } else {\n            blockNode.classList.toggle('rellax-visible', false);\n            rellax.detach();\n            rellax.detached = true;\n          }\n        }\n      });\n    }\n  };\n\n  window.scrollParallax = function (scrollY) {\n    blockNodes.forEach(function (blockNode) {\n      var rellax = blockNode[rellaxString];\n\n      if (rellax) {\n        blockNode.classList.toggle('rellax-animate', false);\n        blockNode.classList.toggle('rellax-visible', false);\n        blockNode[rellaxString].refresh(scrollY);\n        blockNode[rellaxString].detach();\n      }\n    });\n  };\n}\n\n},{\"../base/partials/javascripts/rellax-parallax\":16}],24:[function(require,module,exports){\n\"use strict\";\n\nvar _mousetrap = _interopRequireDefault(require(\"mousetrap\"));\n\nvar _pell = _interopRequireDefault(require(\"pell/dist/pell\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar baseSelector = '[data-plugin=pell-editor]';\nvar baseNode = document.querySelector(baseSelector);\n\nvar detectContentEditable = function detectContentEditable() {\n  if (!document.documentElement.contentEditable) {\n    return false;\n  } else {\n    var div = document.createElement('div');\n    div.contentEditable = true;\n    return div.contentEditable;\n  }\n};\n\nif (baseNode && detectContentEditable()) {\n  // <div class=\"form-control h-auto d-none\" spellcheck=\"false\"></div>\n  var textareaNode = baseNode;\n  textareaNode.style.display = 'none';\n  var html = '<div class=\"pell-editor ' + textareaNode.className + '\" style=\"height:auto;\" spellcheck=\"false\">' + '<div class=\"pell\"></div>' + '</div>';\n  textareaNode.insertAdjacentHTML('afterEnd', html);\n  var editorNode = textareaNode.nextElementSibling;\n  var pellNode = editorNode.firstElementChild;\n  var actions = [{\n    name: 'bold',\n    icon: 'bold',\n    title: 'Bold',\n    result: 'bold'\n  }, {\n    name: 'italic',\n    icon: 'italic',\n    title: 'Italic',\n    result: 'italic'\n  }, {\n    name: 'underline',\n    icon: 'underline',\n    title: 'Underline',\n    result: 'underline'\n  }, {\n    name: 'strikethrough',\n    icon: 'strikethrough',\n    title: 'Strikethrough',\n    result: 'strikethrough'\n  }, {\n    name: 'olist',\n    icon: 'olist',\n    title: 'Ordered list',\n    result: 'insertOrderedList'\n  }, {\n    name: 'ulist',\n    icon: 'ulist',\n    title: 'Unordered list',\n    result: 'insertUnorderedList'\n  }, {\n    name: 'indent',\n    icon: 'indent',\n    title: 'Indent',\n    result: 'indent'\n  }, {\n    name: 'outdent',\n    icon: 'outdent',\n    title: 'Outdent',\n    result: 'outdent'\n  }];\n  actions = actions.map(function (item) {\n    item.icon = '<i class=\"icon icon-edit-' + item.icon + '\"></i>';\n    item.result = _pell.default.exec.bind(this, item.result);\n    return item;\n  });\n\n  _pell.default.init({\n    element: pellNode,\n    defaultParagraphSeparator: 'p',\n    actions: actions,\n    styleWithCSS: true,\n    onChange: function onChange(html) {\n      textareaNode.textContent = html;\n    }\n  });\n\n  var editorActionbarNode = pellNode.querySelector('.pell-actionbar');\n  var editorContentNode = pellNode.querySelector('.pell-content'); // Form submit hotkey\n\n  (0, _mousetrap.default)(editorContentNode).bind(['shift+enter', 'mod+enter'], function (e) {\n    console.log('submit!');\n    e.preventDefault();\n  }); // Editor hotkeys\n\n  (0, _mousetrap.default)(editorContentNode).bind('mod+b', function (e) {\n    _pell.default.exec('bold');\n\n    e.preventDefault();\n  });\n  (0, _mousetrap.default)(editorContentNode).bind('mod+i', function (e) {\n    _pell.default.exec('italic');\n\n    e.preventDefault();\n  });\n  (0, _mousetrap.default)(editorContentNode).bind('mod+u', function (e) {\n    _pell.default.exec('underline');\n\n    e.preventDefault();\n  });\n  (0, _mousetrap.default)(editorContentNode).bind('tab', function (e) {\n    _pell.default.exec('indent');\n\n    e.preventDefault();\n  });\n  (0, _mousetrap.default)(editorContentNode).bind('shift+tab', function (e) {\n    _pell.default.exec('outdent');\n\n    e.preventDefault();\n  }); // Manage focus outline of the container\n\n  editorContentNode.addEventListener('focus', function () {\n    editorNode.classList.add('focus');\n  });\n  editorContentNode.addEventListener('blur', function () {\n    editorNode.classList.remove('focus');\n  }); // Prevent blur event when clicking toolbar\n\n  editorActionbarNode.addEventListener('mousedown', function (e) {\n    e.preventDefault();\n  });\n}\n\n},{\"mousetrap\":7,\"pell/dist/pell\":8}],25:[function(require,module,exports){\n\"use strict\";\n\nvar _src = _interopRequireDefault(require(\"detect-it/src\"));\n\nvar _smoothScroll = _interopRequireDefault(require(\"smooth-scroll/src/js/smooth-scroll\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar baseSelector = 'body[data-plugin=smooth-scroll]';\nvar baseNode = document.querySelector(baseSelector);\n\nif (baseNode) {\n  var linkSelector = 'a[href*=\"#\"]';\n  var smoothScrollMode = 'mouse';\n\n  if (_src.default.primaryInput === smoothScrollMode) {\n    // easeInOutQuad, easeInOutCubic, easeInOutQuart, easeInOutQuint\n    var scroll = new _smoothScroll.default(linkSelector, {\n      speed: 500\n    });\n    window.animateScroll = scroll.animateScroll;\n    window.cancelScroll = scroll.cancelScroll;\n\n    var handleScroll = function handleScroll(e) {\n      //console.log(e.detail.anchor);\n      if (e.type === 'scrollStart') {\n        var nodeOffsetTop = Math.round(e.detail.anchor.getBoundingClientRect().top + window.pageYOffset);\n        window.scrollParallax && window.scrollParallax(nodeOffsetTop);\n        window.toggleParallax && window.toggleParallax(false);\n      }\n\n      if (e.type === 'scrollStop') {\n        window.toggleParallax && window.toggleParallax(true);\n      }\n    };\n\n    document.addEventListener('scrollStart', handleScroll, false);\n    document.addEventListener('scrollStop', handleScroll, false);\n  } else {\n    var linkNodes = document.querySelectorAll(linkSelector);\n\n    for (var i = 0; i < linkNodes.length; i++) {\n      linkNodes[i].addEventListener('click', function (e) {\n        var href = e.currentTarget.getAttribute('href');\n        var node = document.querySelector(href);\n        var nodeOffsetTop = node ? Math.round(node.getBoundingClientRect().top + window.pageYOffset) : 0;\n        window.scrollParallax && window.scrollParallax(nodeOffsetTop);\n        node ? node.scrollIntoView(true) : window.scrollTo({\n          top: 0\n        });\n        e.preventDefault();\n      });\n    }\n  }\n}\n\n},{\"detect-it/src\":3,\"smooth-scroll/src/js/smooth-scroll\":9}]},{},[12]);\n"],"file":"index.js"}